Class D4DNewBeamBase : D4Actor
{
	private bool BeamFlags;
	protected int BeamCount, Timer;
	protected bool KeepKid;
	D4DNewBeamBase 	Parent, Child;
	
	//flagdef MoveWithSource: 
	
	Name 	SpriteName;
	int		FrameMin, FrameMax,
			MaxBeams;
	
	double 	LengthMin, LengthMax,
			WidthMin, WidthMax,
			AngleMin, AngleMax,
			PitchMin, PitchMax,
			TurnMin, TurnMax,
			OffX, OffY, OffZ;
			
	bool	UseDeathState;
	
	// If true, jump to the death state instead of destroying itself. Useful for
	// animations.
	Property UseDeathState:		UseDeathState;
	
	// The four letter sprite name to use.
	Property SpriteName:		SpriteName;
	
	// Random sprite frame to choose. Valid ranges are [Fr_A, Fr_Z].
	Property Frames:			FrameMin, FrameMax;
	
	// How much pitch, angle, length and width to randomize for each segment.
	Property Pitches:			PitchMin, PitchMax;
	Property Angles:			AngleMin, AngleMax;
	Property Lengths:			LengthMin, LengthMax;
	Property Widths:			WidthMin, WidthMax;
	Property Turn:				TurnMin, TurnMax;
	
	// Maximum 
	Property MaxBeams:			MaxBeams;
	Property Offsets:			OffX, OffY, Offz;
	Property Timer:				Timer;
	Default
	{
		D4DNewBeamBase.UseDeathState false;
		D4DNewBeamBase.MaxBeams 25;
		D4DNewBeamBase.Offsets 10.0, 4.1, -2.7;
		D4DNewBeamBase.Turn 30, 30;
		RenderStyle "Add";
		Radius 1;
		Height 1;
		XScale 0.1;
		YScale 1.0;
		Projectile;
		+BRIGHT
		+NOINTERACTION
	}
	
	// Propagates the chain of children, ensuring they all follow through.
	void SetKeeping(bool keep)
	{
		KeepKid = keep;
		if (Child)	Child.SetKeeping(keep);
	}
	
	override void OnDestroy()
	{
		if (Child && !KeepKid)
		{
			Child.Destroy();
		}
		Super.OnDestroy();
	}
	
	
	
	// For whatever fancy effects can happen, use the death state. Disables
	// child chain destruction so they can disappear on their own whenever they want.
	// Only applies if UseDeathState is true. Otherwise, destroy it.
	override void Die(Actor source, Actor inflictor, int dmgflags, Name MeansOfDeath)
	{
		if (!bKILLED)
		{
			bKILLED = true;
			
			// Only the parent should call this since this will propagate into
			// children, and they'll call it needlessly over and over again.
			if (!Parent)	
				SetKeeping(UseDeathState);
				
			if (UseDeathState)
			{
				if (Child)		Child.Die(source, inflictor, dmgflags, MeansOfDeath);
				SetState(ResolveState("Death"));
			}
			else	{ 	Destroy(); return;	}
		}
	}
	
	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_USER);
		Super.BeginPlay();
	}
	
	// Set up the scaling times
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		// If this is being spawned manually instead of by a spawner, set some
		// things up.
		
		if (!Parent)
		{
			int check = GetSpriteIndex(SpriteName);
			if (check < 0)
			{	ThrowAbortException("SpriteName is bad! Check to make sure it's defined!");	return;	}
			Sprite = check;
			
			if (FrameMin < Fr_A || FrameMin > Fr_Z || FrameMax < Fr_A || FrameMax > Fr_Z)
			{	ThrowAbortException("Frames parameters must be in range [Fr_A, Fr_Z]");	return;	}
			
			Frame = random(FrameMin, FrameMax);
		
			Scale.Y = frandom(LengthMin, LengthMax);
			Scale.X = frandom(WidthMin, WidthMax);
			Pitch += 90.0;
		}		
	}
	
	void UpdateBeam()
	{
		if (bKILLED)	return;
		
		// Perform movement code here.
		Scale.Y = frandom(LengthMin, LengthMax);
		double SY = Scale.Y * 100.0;
		double SY2 = SY ** 2;
		double RealPitch = Pitch - 90.0;
		double Dist = 0;
		
		// Never check for the position. That's extremely resource intensive.
		int WarpFlags = WARPF_NOCHECKPOSITION;
		if (!bDONTINTERPOLATE)	WarpFlags |= WARPF_INTERPOLATE;
		
		if (Parent)
		{
			Scale.X = Parent.Scale.X;
			Frame = Parent.Frame;
			Tracer = Parent.Tracer;
			Translation = Parent.Translation;
			
			double PSY = Parent.Scale.Y * 100.0;
			double pit = Parent.Pitch - 90;
			
			Warp(Parent, cos(pit) * PSY, 0, -sin(pit) * PSY, 0, WarpFlags);
		}
		else
		{
			Frame = random(FrameMin, FrameMax);
			Scale.X = frandom(WidthMin, WidthMax);
			if (Target.Player)
			{
				Vector3 x, y, z, origin;
				[x, y, z] = MC_CoordUtil.GetAxes(target.pitch,target.angle,target.roll);
				origin = target.Vec2OffsetZ(0,0,target.player.viewz) + OffX * x + OffY * y + OffZ * z;
				Warp(Target, origin.x, origin.y, origin.z, 0, WarpFlags|WARPF_ABSOLUTEPOSITION);
			}
			else if (Target)
			{
				Warp(Target, OffX, OffY, OffZ, 0, WarpFlags);
			}
		}
		
		// Movement complete.
		// Now do the turning.
		if (Tracer)
		{
			Dist = Distance3DSquared(tracer);
			Pitch -= 90.0;
			//A_Face(Tracer,TurnLimit,PitchLimit,0,0,FAF_MIDDLE);
			
			if (Parent)	
			{
				double NextTurn = frandom(TurnMin, TurnMax);
				if (NextTurn > 0.0)
					TurnAng(Tracer, NextTurn);
				else
					A_Face(Tracer, 0, 0, 0, 0, FAF_BOTTOM);
			}
			else if (Target) Pitch = Target.Pitch;
			
			if (Dist > SY2)
			{
				A_SetPitch(pitch + FRandom(PitchMin, PitchMax));
				A_SetAngle(angle + FRandom(AngleMin, AngleMax));
			}
			Pitch += 90.0;
		}
		else
		{
			A_SetPitch(pitch + FRandom(PitchMin, PitchMax));
			A_SetAngle(angle + FRandom(AngleMin, AngleMax));
		}
		
		if (Dist > SY2)
		{
			if (Child)
			{
				Child.UpdateBeam();
			}
			else if ((BeamCount < MaxBeams))
			{
				Child = D4DNewBeamBase(Spawn(GetClass(), pos));
				Child.Sprite = Sprite;
				Child.Frame = Frame;
				Child.Tracer = Tracer;
				Child.Target = Target;
				Child.Master = Master;
				Child.Parent = self;
				Child.Angle = Angle;
				Child.Pitch = Pitch;
				Child.Translation = Translation;
				Child.BeamCount = BeamCount + 1;
				Child.UpdateBeam();
			}
		}
		else 
		{
			if (Child)	
			{
				SetKeeping(false);
				Child.Destroy();
			}
			
			if (Tracer)
				Scale.Y = sqrt(Dist) * 0.01;
		}
	}
	
	States
	{
	Spawn:
		---- A 0;
		---- A 1 
		{
			if (!Target)	
			{
				SetKeeping(false);
				Destroy();
				return;
			}
			if (!Parent)	UpdateBeam();
			else A_SetTics(-1);
		}
		Wait;
	// Without someone using these, modeldefs will throw a fit and refuse to start.
	Precache:
		X202 BYZ 0;
		X206 FGHIJKLM 0;
	Death:
		---- A 1;
		Stop;
	}
}

Class NewLightningBeamPrimary : D4DNewBeamBase
{
	Default
	{
	//	+DONTINTERPOLATE
		D4DNewBeamBase.Offsets 10.0, 4.1, -4.7;
		D4DNewBeamBase.SpriteName 'X206';
		D4DNewBeamBase.Frames Fr_F, Fr_M;
		D4DNewBeamBase.Widths 0.10, 0.10;
		D4DNewBeamBase.Lengths 0.2, 0.6;
		D4DNewBeamBase.Angles -10, 10;
		D4DNewBeamBase.Pitches -10, 10;
	}
}

Class SMMBeamPlayer : D4DNewBeamBase
{
	Default
	{
		D4DNewBeamBase.SpriteName 'X202';
		D4DNewBeamBase.Frames Fr_B, Fr_B;
		D4DNewBeamBase.Widths 0.35, 0.35;
		D4DNewBeamBase.Lengths 1.0, 1.0;
		D4DNewBeamBase.Angles 0, 0;
		D4DNewBeamBase.Pitches 0, 0;
		Translation "0:255=%[0,0,0]:[1,0,0]";
	}
}

Class SMMBeamWarning : D4DNewBeamBase
{
	Default
	{
		D4DNewBeamBase.SpriteName 'X202';
		D4DNewBeamBase.Frames Fr_B, Fr_B;
		D4DNewBeamBase.Widths 0.35, 0.35;
		D4DNewBeamBase.Lengths 4.0, 4.0;
		D4DNewBeamBase.Angles 0, 0;
		D4DNewBeamBase.Pitches 0, 0;
		Translation "0:255=%[0,0,0]:[1,0.5,0]";
	}
}

Class RevenantLaserWhite : D4DNewBeamBase
{
	Default
	{
		D4DNewBeamBase.SpriteName 'X202';
		D4DNewBeamBase.Frames Fr_B, Fr_B;
		D4DNewBeamBase.Widths 0.05, 0.05;
		D4DNewBeamBase.Lengths 4.0, 4.0;
		D4DNewBeamBase.Angles 0, 0;
		D4DNewBeamBase.Pitches 0, 0;
		Translation "0:255=%[0,0,0]:[1,1,1]";
	}
}

Class RevenantLaserYellow : RevenantLaserWhite	{ Default { Translation "0:255=%[0,0,0]:[1,1,0]"; } }
Class RevenantLaserOrange : RevenantLaserWhite	{ Default { Translation "0:255=%[0,0,0]:[1,0.5,0]"; } }
Class RevenantLaserRed : RevenantLaserWhite 	{ Default { Translation "0:255=%[0,0,0]:[1,0,0]"; } }

Class NewCarrionBeamMerger : D4DNewBeamBase
{
	double OutTime;
	Default
	{
		D4DNewBeamBase.SpriteName 'X206';
		D4DNewBeamBase.Frames Fr_F, Fr_M;
		D4DNewBeamBase.Widths 0.05, 0.05;
		D4DNewBeamBase.Lengths 0.2, 0.6;
		D4DNewBeamBase.Angles -4, 4;
		D4DNewBeamBase.Pitches -4, 4;
		D4DNewBeamBase.UseDeathState true;
		Translation "0:255=%[0,0,0]:[1,0.1,0.1]";
	}
	
	States
	{
	Death:
		---- A 1
		{
			OutTime = Scale.X / 4.0;
		}
		---- A 1
		{
			Scale.X -= OutTime;
			if (Scale.X <= 0.0)
			{
				Destroy();
				return;
			}
		}
		Wait;
	}
}