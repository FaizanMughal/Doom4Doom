// All code by Major Cooke. Please give credit if used.

Class D4Msg play
{
	static void PlainMsg( Name fnt, string txt, Vector2 pos, Vector2 vsize = (0,0), int talign = -1, Vector2 balign = (0,0), int color = Font.CR_UNTRANSLATED, Vector3 time = (0,0,0), int wrap = 0, uint id = 0, int layer = BaseStatusBar.HUDMSGLayer_OverHUD )
	{
		notHudMessageHandler.PlainMsg(fnt, txt, pos, vsize, talign, balign, color, time, wrap, id, layer);
	}
	
	static void ClearMsg(uint id)
	{
		notHudMessageHandler.PlainMsg("smallfont", "", (0,0), id: id);
	}
}

Class D4D_Utility play
{
	//==========================================================================
	// AdjustToLedge
	// 
	// Attempts to fit an actor into a new position. Used by ledge grabbing
	// to make sure the player doesn't get stuck in places they can't fit.
	//==========================================================================
	static bool AdjustToLedge(Actor mo, Vector3 p, double stepadd = 0.0, bool checkonly = false)
	{
		if (!mo || mo.Radius < 1.0)	return false;
		
		// Iterate through the radius of the actor, finding the highest position
		// available.
		
		Vector3 old = mo.pos;
		double GridIncrement = 1.0;
		double Radius = mo.Radius / 2.0;
		double MaxStepHeight = mo.MaxStepHeight + stepadd;
		int GZFlags = GZF_ABSOLUTEPOS|GZF_ABSOLUTEANG;
		
		double newz = p.z;
		double ceil = 32767.0;
		for (double xx = p.x - Radius; xx <= p.x + Radius; xx += GridIncrement)
		{
			for (double yy = p.y - Radius; yy <= p.y + Radius; yy += GridIncrement)
			{
				newz = Max(newz, mo.GetZAt(xx, yy, 0, GZFlags));
				ceil = Min(ceil, mo.GetZAt(xx, yy, 0, GZFlags|GZF_CEILING));
			}
		}
		
		if ((newz - p.z >= MaxStepHeight) ||	// Out of range.
			(ceil - newz < mo.Height) ||		// Won't fit.
			(!mo.CheckPosition(p.XY))) 			// Not a good position.
			return false;
		
		if (!checkonly)
		{
			mo.SetOrigin((p.x, p.y, newz), true);
			mo.floorz = newz;
		}
		return true;
	}
	
	// Code by DoomKrakken, modified by Major Cooke
	Static Vector3 GetLedgeOffset(Actor Activator, double MaxHeight = 72)
	{
		PlayerInfo Player = Activator.Player;
		Vector3 OldPos = Activator.Pos;
		bool PlayerOnGround = Player && Player.Mo && Player.Mo == Activator && Player.OnGround;
		
		if (PlayerOnGround)	MaxHeight /= 2.0;
		
		Activator.SetXYZ(OldPos + (0, 0, MaxHeight)); //[DoomKrakken]: Use SetXYZ to change the actor's position for testing purposes, without actually moving him.  This way he can detect 3D floors using GetZAt (since it can only be used to detect 3D floors beneath the player).
		For (double i = Activator.Radius; i <= Activator.Radius * 2; i += 1.0) //[DoomKrakken]: If attempting to mantle at an angle to the ledge, the check may fall short and yield a negative result.  This'll make sure that it won't happen.
		{
			Vector3 np = Activator.Vec3Angle(i, Activator.Angle, 0);
			Int LedgeFloorZ = Activator.GetZAt(i, 0, 0, GZF_3DRESTRICT);
			Int LedgeCeilingZ = Activator.GetZAt(i, 0, 0, GZF_3DRESTRICT|GZF_CEILING);
			If (LedgeFloorZ - OldPos.Z > Activator.MaxStepHeight && LedgeFloorZ - OldPos.Z <= MaxHeight && LedgeCeilingZ - LedgeFloorZ >= Activator.Height && Activator.CheckPosition(np.XY))
			{
			//	Console.PrintF("%f", LedgeFloorZ - OldPos.Z);
				Activator.SetXYZ(OldPos);
				Return (i, 0, min(LedgeFloorZ - OldPos.Z, Activator.Height));
			}
		}
		Activator.SetXYZ(OldPos);
		Return (0, 0, 0);
	}
	
	//==========================================================================
	// CheckTouching
	// 
	// Checks if the overlapping radius and height of two are touching each other.
	// Based on cubes.
	//==========================================================================
	static bool CheckTouching(Actor caller, Actor other)
	{
		if (!caller || !other)	return false;
		
		double blockdist = caller.radius + other.radius;
		if (abs(caller.pos.x - other.pos.x) > blockdist ||
			abs(caller.pos.y - other.pos.y) > blockdist)
			return false; // Not touching horizontally.
			
		if ((caller.pos.z > other.pos.z + other.height) ||
			(caller.pos.z + caller.height < other.pos.z))
			return false; // Not touching vertically.
		
		return true;
	}
	
	//==========================================================================
	// A test function to count the number of 
	//==========================================================================
	static int, int CountIntersectingLines(Actor mo)
	{
		if (!mo)	return -1, -1;
	
		// Find the line that this actor's centerpoint is closest to
		double dist = mo.radius * 2.0;
		Vector3 pos = mo.pos;
		
		double	radius = mo.radius,
				xp = pos.x + radius,
				xn = pos.x - radius,
				yp = pos.y + radius,
				yn = pos.y - radius;
		
		
		int count[2]; count[0] = 0;	count[1] = 0;
		BlockLinesIterator it = BlockLinesIterator.Create(mo);
		while (it.Next())
		{
			Line current = it.curline;
			
			count[0]++;
			
			// Discard lines that definitely don't intersect the actor's radius
			if ((current.v1.p.x > xp && current.v2.p.x > xp) ||
				(current.v1.p.x < xn && current.v2.p.x < xn) ||
				(current.v1.p.y > yp && current.v2.p.y > yp) ||
				(current.v1.p.y < yn && current.v2.p.y < yn))
				continue; 
			
			count[1]++;
		}
		return count[0], count[1];
	}
	
	static D4D_LineContainer GetIntersectingLines(Actor mo)
	{
		if (!mo || mo.radius <= 0.0)	return null;
	
		// Find the line that this actor's centerpoint is closest to
		Vector3 pos = mo.pos;
		
		double	dist = mo.radius,
				radius = mo.radius,
				xp = pos.x + radius,
				xn = pos.x - radius,
				yp = pos.y + radius,
				yn = pos.y - radius;
		
		let Container = D4D_LineContainer.Create();
		
		BlockLinesIterator it = BlockLinesIterator.Create(mo);
		while (it.Next())
		{
			Line current = it.curline;
			
			// Discard lines that definitely don't intersect the actor's radius
			if ((current.v1.p.x > xp && current.v2.p.x > xp) ||
				(current.v1.p.x < xn && current.v2.p.x < xn) ||
				(current.v1.p.y > yp && current.v2.p.y > yp) ||
				(current.v1.p.y < yn && current.v2.p.y < yn))
				continue; 
			
			Container.AddLine(current);
		}
		
		return Container;
		/*
		// Find the line that is closest based on proximity to end vertices
			double curdist = (current.v1.p - pos.xy + current.v2.p - pos.xy).Length();
			if (linedef == null || curdist < dist)
			{
				linedef = current;
				dist = curdist;
			}
		*/
	}
}

Class D4D_Line play
{
	Line 	lin;
	
	static D4D_Line Create(Line l)
	{
		if (!l)	return null;
	
		let ls = new('D4D_Line');
		ls.lin = l;
		return ls;
	}
}

Class D4D_LineContainer play
{
	Array<D4D_Line> Lines;
	
	static D4D_LineContainer Create()
	{
		let ls = new('D4D_LineContainer');
		ls.Lines.Clear();
		return ls;
	}
	
	void AddLine(Line lin)
	{
		if (!lin)	return;
		
		let linepart = D4D_Line.Create(lin);
		if (linepart)
			Lines.Push(linepart);
	}
}