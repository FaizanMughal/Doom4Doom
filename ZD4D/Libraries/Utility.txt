// All code by Major Cooke. Please give credit if used.

Class D4Msg play
{
	static void PlainMsg( Name fnt, string txt, Vector2 pos, Vector2 vsize = (0,0), int talign = -1, Vector2 balign = (0,0), int color = Font.CR_UNTRANSLATED, Vector3 time = (0,0,0), int wrap = 0, uint id = 0, int layer = BaseStatusBar.HUDMSGLayer_OverHUD )
	{
		notHudMessageHandler.PlainMsg(fnt, txt, pos, vsize, talign, balign, color, time, wrap, id, layer);
	}
	
	static void ClearMsg(uint id)
	{
		notHudMessageHandler.PlainMsg("smallfont", "", (0,0), id: id);
	}
}

Class D4D_Utility play
{
	//==========================================================================
	// AdjustToLedge
	// 
	// Attempts to fit an actor into a new position. Used by ledge grabbing
	// to make sure the player doesn't get stuck in places they can't fit.
	//==========================================================================
	static bool AdjustToLedge(Actor mo, Vector3 p, double stepadd = 0.0, bool checkonly = false)
	{
		if (!mo || mo.Radius < 1.0)	return false;
		
		Vector3 old = mo.pos;
		double GridIncrement = 1.0;
		double Radius = mo.Radius / 2.0;
		double MaxStepHeight = mo.MaxStepHeight + stepadd;
		int GZFlags = GZF_ABSOLUTEPOS|GZF_ABSOLUTEANG;
		
		// Iterate through the radius of the actor, finding the highest position
		// available.
		
		double newz = p.z;
		double ceil = 32767.0;
		for (double xx = p.x - Radius; xx <= p.x + Radius; xx += GridIncrement)
		{
			for (double yy = p.y - Radius; yy <= p.y + Radius; yy += GridIncrement)
			{
				newz = Max(newz, mo.GetZAt(xx, yy, 0, GZFlags));
				ceil = Min(ceil, mo.GetZAt(xx, yy, 0, GZFlags|GZF_CEILING));
			}
		}
		
		if ((newz - p.z >= MaxStepHeight) ||	// Out of range.
			(ceil - newz < mo.Height) ||		// Won't fit.
			(!mo.CheckPosition(p.XY))) 			// Not a good position.
			return false;
		
		if (!checkonly)
		{
			mo.SetOrigin((p.x, p.y, newz), true);
			mo.floorz = newz;
		}
		return true;
	}
	
	//==========================================================================
	// CheckTouching
	// 
	// Checks if the overlapping radius and height of two are touching each other.
	// Based on cubes.
	//==========================================================================
	static bool CheckTouching(Actor caller, Actor other)
	{
		if (!caller || !other)	return false;
		
		double blockdist = caller.radius + other.radius;
		if (abs(caller.pos.x - other.pos.x) > blockdist ||
			abs(caller.pos.y - other.pos.y) > blockdist)
			return false; // Not touching horizontally.
			
		if ((caller.pos.z > other.pos.z + other.height) ||
			(caller.pos.z + caller.height < other.pos.z))
			return false; // Not touching vertically.
		
		return true;
	}
	
	//==========================================================================
	//
	//==========================================================================
	static int, int GetClosestIntersectingLine(Actor mo, Line linedef)
	{
		if (!mo)	return -1, -1;
	
		// Find the line that this actor's centerpoint is closest to
		double dist = mo.radius * 2.0;
		Vector3 pos = mo.pos;
		
		double	radius = mo.radius,
				xp = pos.x + radius,
				xn = pos.x - radius,
				yp = pos.y + radius,
				yn = pos.y - radius;
		
		
		int count[2]; count[0] = 0;	count[1] = 0;
		BlockLinesIterator it = BlockLinesIterator.Create(mo);
		while (it.Next())
		{
			Line current = it.curline;
			
			count[0]++;
			
			// Discard lines that definitely don't intersect the actor's radius
			if ((current.v1.p.x > xp && current.v2.p.x > xp) ||
				(current.v1.p.x < xn && current.v2.p.x < xn) ||
				(current.v1.p.y > yp && current.v2.p.y > yp) ||
				(current.v1.p.y < yn && current.v2.p.y < yn))
				continue; 
			
			count[1]++;
			
			// Find the line that is closest based on proximity to end vertices
			double curdist = (current.v1.p - pos.xy + current.v2.p - pos.xy).Length();
			if (linedef == null || curdist < dist)
			{
				linedef = current;
				dist = curdist;
			}
		}
		return count[0], count[1];
	}
}

Class D4D_LineSector play
{
	Line 	ln;
	Sector	sec;
	
	static D4D_LineSector Create(Line l, Sector s)
	{
		let ls = new('D4D_LineSector');
		ls.ln = l;
		ls.sec = s;
		return ls;
	}
}