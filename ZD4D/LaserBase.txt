/*==============================================================================
================================================================================
									Trail Beams
================================================================================
	A guide on how to use these will come later.
	
	-----------
	Trail Types
	-----------
	
	- TrailBeam -
	Standard non-moving trail.
	
	- MovingTrailBeam -
	Interpolates with the shooter's movement and turning.
	
	- TrailBeamStaticScaling -
	Does not move. Scales in, holds, and scales out by tic settings.
	
	-----------
	Spawn Types
	-----------
	
	- TrailBeamStaticScalingSpawner -
	- TrailBeamJitterSpawner -
	

==============================================================================*/


Class MovingTrailBeam : Actor 
{
	const NoSpawn = 256;
	double dist;
	int t;
	int Zoffset;
	double UAngle;
	double UPitch;
	Vector3 pa, pb;
	double UXa, UXb;
	double UYa, UYb;
	double UZa, UZb;
	double time;
	double UScale;
	int pflags;
	int neg;
	Default 
	{
		+NOINTERACTION
		+FLATSPRITE
		+BRIGHT
		+ROLLCENTER
		YScale 0.25; //Don't touch this! Otherwise the trail will become broken up!
		XScale 0.03; //This modifies the width of the beam. It is safe to play around with.
		Alpha 0;
		RenderStyle "Add";
	}
	// DO NOT add a translation. If you need to change the colors, make a sprite
	// entry in TEXTURES lump and use BLEND. NEVER TRANSLATE!
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			// Sets how long to split the scaling-in effect.
			time = 3.0;
			zoffset = 16;
			// Set this to the actor's same name. The TID will prevent it spawning infinitely (tid * 256).
			//A_SpawnItemEx("MovingTrailBeam",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
		}
		Goto Process;
	Process:
		"####" "#" 0
		{
			if (!pflags)	{ pflags = WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEOFFSET;	}
			A_Warp(DefPtr,0,0,zoffset,0,WARPF_NOCHECKPOSITION);
			// If it's a secondary trail (vertical)
			/*
			if (tid > 0)	
			{	
				Thing_ChangeTID(0,0);
				roll = pitch + 90;
				pitch = 90;
				angle += 90;
			}
			*/
			// Save our current information so we know how to properly interpolate whenever
			// the owner moves.
			neg = (Scale.X < 0) ? 1 : 0;
			UScale = Scale.X;
			UAngle = angle;
			UPitch = pitch;
			dist = GetDistance(false, TargetPtr);
			pa = pos;
			
			// Move to the shooter so we can get just how far out we are.
			A_Warp(TargetPtr,0,0,0,0,WARPF_NOCHECKPOSITION);
			pb = pa - pos;
			
			// Now move back without interpolating. Otherwise it'll look weird.
			A_Warp(TargetPtr, pb.x, pb.y, pb.z, 0, WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEOFFSET);
			angle = UAngle;
			pitch = UPitch;
		}
		"####" "#" 1 
		{
			A_FadeIn(1.0,FTF_CLAMP);
			A_Warp(TargetPtr, pb.x + vel.x, pb.y + vel.y, pb.z + vel.z, 0, pflags);
			angle = UAngle;
			pitch = UPitch;
		}
		"####" "#" 1 
		{
			// Keep 'shrinking'. NEVER fade out!
			if (neg)
			{
				A_SetScale(Scale.X - (UScale / Max(1.0, time)), Scale.Y);
				if (Scale.X >= 0)	{ return ResolveState("Null"); }
			}
			else
			{
				A_SetScale(Scale.X - (UScale / Max(1.0, time)), Scale.Y);
				if (Scale.X <= 0)	{ return ResolveState("Null"); }
			}
			A_Warp(TargetPtr, pb.x + vel.x, pb.y + vel.y, pb.z + vel.z ,0, pflags);
			angle = UAngle;
			pitch = UPitch;
			return ResolveState(null);
		}
		Wait;
	}
}

Class TrailBeam : Actor 
{
	const ZOffset = 16;
	const NoSpawn = 256;
	const PFlags = WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_COPYVELOCITY|WARPF_ABSOLUTEOFFSET;
	double time;
	double UScale;
	int neg;
	Default 
	{
		+NOINTERACTION
		+FLATSPRITE
		+BRIGHT
		+ROLLCENTER
		YScale 0.25; //Don't touch this! Otherwise the trail will become broken up!
		XScale 0.03; //This modifies the width of the beam. It is safe to play around with.
		Alpha 0;
		RenderStyle "Add";
	}
	// DO NOT add a translation. If you need to change the colors, make a sprite
	// entry in TEXTURES lump and use BLEND. NEVER TRANSLATE!
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			// Sets how long to split the scaling-in effect.
			time = 3.0;
			
			// Set this to the actor's same name. The TID will prevent it spawning infinitely (tid * 256).
			//A_SpawnItemEx("TrailBeam",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			return ResolveState("Process");
		}
	Process:
		"####" "#" 1
		{
			//A_Warp(DefPtr,0,0,ZOffset,0,WARPF_NOCHECKPOSITION);
			UScale = Scale.X;
			neg = ((UScale < 0) ? 1 : 0);
			// If it's a secondary trail (vertical)
			/*
			if (tid > 0)	
			{	
				Thing_ChangeTID(0,0);
				roll = pitch + 90;
				pitch = 90;
				angle += 90;
			}
			*/
			A_FadeIn(1.0,FTF_CLAMP);
		}
		"####" "#" 1 
		{
			// Keep 'shrinking'. NEVER fade out!
			
			if (neg)
			{
				A_SetScale(Scale.X - (UScale / Max(1.0, time)), Scale.Y);
				if (Scale.X >= 0)	{ return ResolveState("Null"); }
			}
			else
			{			
				A_SetScale(Scale.X - (UScale / Max(1.0, time)), Scale.Y);
				if (Scale.X <= 0)	{ return ResolveState("Null"); }
			}
			return ResolveState(null);
		}
		Wait;
	}
}


//By static, I mean non-moving. Not static rifle.
Class TrailBeamStaticScaling : Actor 
{
	enum TBSS
	{
		ZOffset = 16,
		NoSpawn = 256,
		PFlags = WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_COPYVELOCITY|WARPF_ABSOLUTEOFFSET,
	};
	double  dist;
	int t;
	double  timeup;
	double  timedown;
	double  UScale;
	int stoff;
	int neg;
	double  USin;
	int wait;
	int stage;
	
	Default 
	{
		Projectile;
		+NOINTERACTION
		+ROLLSPRITE
		+FLATSPRITE
		+ROLLCENTER
		+BRIGHT
		//RenderStyle "Add";
		XScale 0.16;
		YScale 0.248;
		Species "LaserKillable"; //So the Monster; can 'end' its attack if interrupted.
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay
		{
			timeup = 10.0;
			wait = 30;	//
			timedown = 7.0;
			
			// Set this to the actor's same name. The TID will prevent it spawning infinitely (tid * 256).
			//A_SpawnItemEx("TrailBeamStaticScaling",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME,tid * 256,1);
			return ResolveState("Setup");
		}
	Setup:
		"####" "#" 0
		{
			/*
			// If it's a secondary trail (vertical)
			if (tid > 0)	
			{
				roll = pitch + 90.0;
				pitch = 90.0;
				angle += 90.0;
				Thing_ChangeTID(0,0);
			}
			*/
			UScale = Scale.X;
			Scale.X = 0;
		}
	Process:
		"####" "#" 1 
		{
			if (!stage)
			{
				USin += ((timeup >= 1.0) ? (90.0/timeup) : (90.0 / 35.0));
				A_SetScale(sin(USin) * UScale, Scale.Y);
				if (USin >= 90.0)	{	stage = 1;	}
			}
			else if (stage == 1)
			{
				USin = 90.0;
				wait--;
				if (wait <= 0)		{	stage = 2;	}
			}
			else
			{
				USin -= ((timedown >= 1.0) ? (90.0/timedown) : (90.0 / 35.0));
				A_SetScale(sin(USin) * UScale, Scale.Y);
				if (Scale.X <= 0)	{ return ResolveState("Null"); }
			}
			
			return ResolveState(null);
		}
		Wait;
	Death:
		"####" "#" 1
		{
			if (Scale.X <= 0)	{ return ResolveState("Null"); }
			USin -= ((timedown >= 1.0) ? (90.0/timedown) : (90.0 / 35.0));
			A_SetScale(sin(USin) * UScale, Scale.Y);
			return ResolveState(null);
		}
		Wait;
	}
}

//==============================================================================
//==============================================================================
// Laser Spawners
//==============================================================================
//==============================================================================

Class TrailBeamStaticScalingSpawner : Actor 
{
	enum TBSSS
	{
		SpawnFlags = SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERSCALE,
	};
	const StepDistance = 31;
	const AngleRandom = 6.0; // The boundaries of angle changing (random(-AngleRandom,AngleRandom))
	const PitchRandom = 6.0; // ^ for pitch
	double UPitch;
	double UAngle;
	double dista, distb; 
	double checkfova, checkfovb;
	int checksight;
	double checkrangea, checkrangeb;
	//[0] = Current distance travelled
	//[1] = How much further to go
	int DoCheckRange;
	int DoCheckSight;
	int DoCheckFOV;
	int MaxDistance;
	int flags;
	//[0] = Current distance travelled
	//[1] = How much further to go
	Default 
	{
		Projectile;
		+NOCLIP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
		XScale 0.16;
		YScale 0.25;
		Species "LaserKillable";
	}
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			MaxDistance = 30000;
			DoCheckSight = 0;
			DoCheckRange = 0;
			DoCheckFOV = 0;
			checkrangea = 4096;
			checkfova = 90.0;
			
			//Include this if one wishes to spawn a laser which co-works with this one.
			A_SpawnItemEx("TrailBeamJitterSpawner",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS);

			A_RearrangePointers(DefPtr,TargetPtr,DefPtr,4);
			A_FaceTracer(0,0,0,0,FAF_MIDDLE);
			// Grab the velocity IMMEDIATELY.
			if (target) { vel = target.vel; }
			
			if (MaxDistance <= 0)		{	MaxDistance = 		30000;	}
			if (checkrangea <= 0)		{	checkrangea = 		4096;	}
			if (checkfova <= 0.0)		{	checkfova =		90.0;	}
			
			// The angle and pitch won't change so go ahead and save it now.
			UPitch = pitch;
			UAngle = angle;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			
			// dista = distance currently travelled.
			// distb = maximum distance.
			while ((dista < distb))
			{
				if (DoCheckRange)		{	checkrangeb = (!(A_CheckRange(checkrangea,"Null",false)) ? 1 : 0);	}
				else						{	checkrangeb = 1;	}
				
				if (DoCheckSight)		{	checksight = (!(A_CheckSight("Null")) ? 1 : 0);	}
				else						{	checksight = 1;	}
				
				if (DoCheckFOV)		{	checkfovb = ((abs(GetAngle(GAF_RELATIVE|GAF_SWITCH,Player1)) <= checkfova) ? 1 : 0);	}
				else						{	checkfovb = 1;		}
				
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				if (checkrangeb && checksight && checkfovb)
				{	A_SpawnItemEx("TrailBeamStaticScaling",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,SpawnFlags);	}
				A_Warp(DefPtr,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
		}
		Stop;
	}
}

Class TrailBeamJitterSpawner : Actor 
{
	const SpawnFlags = 	SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_TRANSFERSCALE|
						SXF_TRANSFERPITCH|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERTRANSLATION;
	const Straight = 0.0000000001;
	const StepDistance = 31;
	int count;
	int choke;
	int chokemin;
	int chokemax;
	int checksight;
	int checkrangea, checkrangeb;
	Vector3 P;
	double UX;
	double UY;
	double UZ;
	double UPitch;
	double UAngle;
	double checkfova, checkfovb;
	double dista, distb;
	//[0] = Current distance travelled
	//[1] = How much further to go
	int InRange;
	int DoCheckRange;
	int DoCheckSight;
	int DoCheckFOV;
	int MaxDistance;
	double UAngleRandom;
	double UPitchRandom;
	Default 
	{
		Projectile;
		+NOCLIP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
		XScale 0.08;
		YScale 0.25;
		Species "LaserKillable";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			DoCheckRange = 0;			// Use Range Checker? Boolean. 
			DoCheckSight = 0;			// Use Sight Checker? Boolean. 
			DoCheckFOV = 0;			// Use Angle Checker? Boolean.
			
			count = 0; 				// How many tics this should respawn itself.
			MaxDistance = 30000;		// The absolute total length it can travel.
			
			checkrangea = 4096;		// How far in range it must be for it to spawn for a player.
			checkfova = 90.0;		// The FOV this must be in for the player.
			
			// Choke determines how often the laser should reorient itself to 
			// remain on target. The higher it goes, the more sporadic it will be.
			chokemin = 1;				// Minimum choke.
			chokemax = 7;				// Maximum choke.
			
			// Angle and pitch to randomize whenever not being choked.
			// If you want it straight, use the defined keyword Straight in these
			// parameters.
			UAngleRandom = 6.0;
			UPitchRandom = 6.0;
			return ResolveState("Setup");
		}
	Setup:
		TNT1 A 0
		{
			A_RearrangePointers(DefPtr,TargetPtr,DefPtr,4);
			// Grab the velocity IMMEDIATELY.
			if (target) { vel = target.vel; }
			
			// Establish defaults if unspecified.
			if (MaxDistance <= 0)		{	MaxDistance = 		30000;	}
			if (checkrangea <= 0)	{	checkrangea = 	4096;	}
			if (chokemin <= 0)			{	chokemin = 		1;		}
			if (chokemax <= 0)			{	chokemax = 		7;		}
			if (UAngleRandom <= 0.0)	{	UAngleRandom =		6.0;	}
			if (UPitchRandom <= 0.0)	{	UPitchRandom =		6.0;	}
			if (checkfova <= 0.0)	{	checkfova =		90.0;	}
			
			// The angle and pitch won't change so go ahead and save it now.
			A_FaceTracer(0,0,0,0,FAF_MIDDLE);
			UPitch = pitch;
			UAngle = angle;
			P = pos;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			choke = random(chokemin, chokemax);
			Scale.X *= 2.5;
			Scale.Y *= 0.485;
			return ResolveState("Sprite");
		}
	Sprite:
		TNT1 A 0 
		{
			A_SetScale(Scale.X*randompick(-1,1), Scale.Y*randompick(-1,1));
			return A_Jump(256,1,2,3,4);
		}
		X206 FGHI 0 { return ResolveState("Moving");	}
	Moving:
		"####" "#" 1
		{
			InRange = 0;
		
			// dista = distance currently travelled.
			// distb = maximum distance.
			// Make sure we always have a valid target.
			while ((dista < distb))
			{
				// Don't randomize the very first beam.
				if (dista > 0)
				{	A_FaceTracer(0,0,0,0,FAF_MIDDLE);	}
				
				// Randomizes the angle of the beams. 
				if (dista < (distb - StepDistance))
				{
					// If we're not about to reach the end, or not hitting the 
					// choker, randomize it. Otherwise, stay on target and go 
					// for the puff.
					if (choke > 0)
					{
						A_SetPitch(pitch + frandom(-UPitchRandom, UPitchRandom));
						A_SetAngle(angle + frandom(-UAngleRandom, UAngleRandom));
						choke--;
					}
					else 
					{	choke = random(chokemin, chokemax);	}
				}
				
				// Check sight, range, and FOV. If disabled, then assume the 
				// check(s) passed. For range, if the range is beyond the player
				// and it previously was, break out of the Loop; and save on 
				// processing time.
				if (DoCheckRange)		
				{	
					if (checkrangeb > 0.0)
					{	InRange = 1;	}
					
					checkrangeb = (!(A_CheckRange(checkrangea,"Null",false)) ? 1 : 0);
					
					if (!checkrangeb && InRange)
					{	break;	}
				}
				else						{	checkrangeb = 1;	}
				
				if (DoCheckSight)		{	checksight = (!(A_CheckSight("Null")) ? 1 : 0);	}
				else						{	checksight = 1;	}
				
				if (DoCheckFOV)		{	checkfovb = ((abs(GetAngle(GAF_RELATIVE|GAF_SWITCH,Player1)) <= checkfova) ? 1.0 : 0.0);	}
				else						{	checkfovb = 1;		}
				
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				if (checkrangeb && checksight && checkfovb)
				{	A_SpawnItemEx("LaserBeamJitter",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,SpawnFlags);	}
				
				A_Warp(DefPtr,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
			
			count--;
			
			if (count <= 0)
			{	return ResolveState("Null");	}
			
			dista = 0.0;
			A_Warp(DefPtr,P.x,P.y,P.z,UAngle,WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEPOSITION|WARPF_ABSOLUTEANGLE);
			pitch = UPitch;
			return ResolveState(null);
		}
		Goto Sprite;
	Death:
		TNT1 A 0;
		Stop;
	}
}

Class LaserBeamJitter : TrailBeam
{
	States
	{
	Spawn:
		"####" "#" 0 NoDelay 
		{
			time = 3.0;
			A_SpawnItemEx("LaserBeamJitter",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERTRANSLATION,tid * 256,1);
			
			return ResolveState("Process");
		}
	}
}

Class WhiteLaserBeamJitter : TrailBeam
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[1,1,1]";
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay 
		{
			time = 3.0;
			A_SpawnItemEx("WhiteLaserBeamJitter",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERTRANSLATION,tid * 256,1);
			
			return ResolveState("Process");
		}
	}
}

Class WhiteLaser : TrailBeamJitterSpawner
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[1,1,1]";
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay
		{
			checkrangea = 1024;
			return ResolveState("Setup");
		}
	}
}

Class RedLaser : TrailBeamJitterSpawner
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[2.0,1.0,1.0]";
		XScale 0.2;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			UPitchRandom = 12.0;
			UAngleRandom = 12.0;
			count = 0;
			return ResolveState("Setup");
		}
	}
}