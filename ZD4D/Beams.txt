


//==============================================================================
/*	Legend:
		(R) = Property is required.
	------------------------------------------------------------
	Property template is:
	<Property Name> <Variable Acceptance Type [= Default Value]>
	------------------------------------------------------------
	D4DBeamSpawnerBase's properties are the following:
	-------------------------------------------
	StartPuff <Actor = "">
		Beam start position to be spawned by hitscan. If left blank, will use
		the spawner's position instead.
		
(R) EndPuff <Actor = "D4DBeamSpawnerBasePuff">
		The impact puff where the beam attempts to stop at. Does not necessarily
		mean contact is always made.
		
(R)	Beam <Actor = "D4DBeamSpawnerBase">
		The lightning beam spawner which does the movement and actual effect
		spawning. 
	
	RandomAim <bool = false>
		If true, chooses a new impact location between steps. Otherwise,
		only chooses one at the start.
	
	(Angle/Pitch)Random <double>
		The random amount of angle/pitch to add per step outside of 'choking'
		(see ChokeMin/Max for details).
		
	AngleStart1Min
	AngleStart1Max
	AngleStart2Min
	AngleStart2Max
	PitchStart1Min
	PitchStart1Max
	PitchStart2Min
	PitchStart2Max
	(Angle/Pitch)Start(1/2)(Min/Max) <double>
		The base pitch/angle to add upon its own when Beam spawns Start(1) or 
		End(2) puff(s) respectively.
		
	Choke <int min>, <int max>
		# of times the beam can 'wander' before 'choking' itself --
		re-orienting back on track and aiming at the EndPuff.
		
	Steps <int min>, <int max>
		# of times to dedicate to 'sub-beam' spawning.
		Sub-beams do not scale out and vanish after Delay(Min/Max) tics pass.
		
	Delays <int min>, <int max>
		# tics sub-beams will stay alive before replacement with the next step.
		
(R)	SpriteName <4 character string> 
		The four characters used to define what sprite to give the beam. 
		This works like the <Sprite> <Frame> <Duration> setup in an actor's
		states, but using only the sprite base itself.
		
		I.e.
		Using a player sprite:
		--> PLAY <-- A 0
		D4DBeamSpawnerBase.SpriteName "PLAY";
		
(R)	Frames <int min>, <int max>
		The random frame range picked to give the beam. 
		Frames are appended by the prefix "Fr_#" where # is a LETTER.
		A-Z is the accepted range for #.
		
		I.e.
		D4DBeamSpawnerBase.Frames Fr_A, Fr_H;
		
	Lengths <double min>, <double max>
		The X scale randomized between min and max for all beams spawned during a step.
		
	Widths <double min>, <double max>
		Y scale equivalent of Lengths. However, width is only randomized when
		starting to spawn a new set of lasers.
	
	MaxDistance <double>
		How far the beam spawner can go before the step ends.
	
	HomingDistance <double>
		When the beam spawner is within this range of the EndPuff, choking is
		constantly enforced to reach the destination.
	
	Failsafe <int = 500>
		Absolute maximum number of movements the beam spawner can make before
		forcefully ending it.
	
	BranchChance <int = 50>
	BranchCMax <int = 1000>
		The basic formula (BranchChance / BranchCMax) for a chance to spawn a branch.
		BranchChance being 0 means it'll never spawn branches.
	
	BranchCount <int>
		The maximum number of branches one single step can spawn.
		
	BranchSize <!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!>
		Do not use/modify. This is set to 1.0 in the base since it cannot be done
		otherwise.
		
		Every new generation of branch will automatically reduce this by 25%,
		affecting several properties to ensure branch spawning does not go
		overboard.
		
	ScaleTime(Min/Max) <int in>, <int out>
		Only the final step spawns beams capable of scaling in/out to nothing.
		Sets how many tics all final beams will take to scale in/out and vanish.
	
	SightCheck <bool = false>
		Checks to see if within the player's FOV (somewhat...) if true.
==============================================================================*/

Class D4DMainBeamSpawner : D4DBeamSpawnerBase 
{
	Default
	{
		D4DBeamSpawnerBase.Beam "D4DMainBeam";
		D4DBeamSpawnerBase.StartPuff "";
		D4DBeamSpawnerBase.EndPuff "BeamSpawnerPuff";
		D4DBeamSpawnerBase.RandomAim false;
		D4DBeamSpawnerBase.PitchStart1Min 0.0;
		D4DBeamSpawnerBase.PitchStart1Max 0.0;
		D4DBeamSpawnerBase.PitchRandom 10.0;
		D4DBeamSpawnerBase.AngleStart1Min 0.0;
		D4DBeamSpawnerBase.AngleStart1Max 0.0;
		D4DBeamSpawnerBase.AngleRandom 10.0;
		D4DBeamSpawnerBase.Choke 1, 3;
		D4DBeamSpawnerBase.Steps 0, 0;
		D4DBeamSpawnerBase.Delays 0, 0;
		D4DBeamSpawnerBase.Lengths 0.02, 0.10;
		D4DBeamSpawnerBase.Widths 0.05, 0.10;
		D4DBeamSpawnerBase.SpriteName "X202";
		D4DBeamSpawnerBase.Frames Fr_B, Fr_B;
		D4DBeamSpawnerBase.MaxDistance 512;
		D4DBeamSpawnerBase.HomingDistance 32;
		D4DBeamSpawnerBase.Failsafe 500;
		//D4DBeamSpawnerBase.BranchChance 0;
		D4DBeamSpawnerBase.ScaleTimeMin 0, 4;
		D4DBeamSpawnerBase.ScaleTimeMax 0, 6;
		D4DBeamSpawnerBase.SightCheck false;
		Translation "0:255=#[255, 192, 96]";
	}
}

Class D4DMainBeam : D4DBeamBase
{
	Default
	{
		D4DBeamBase.StepTime 4;
		D4DBeamBase.ScaleTime 0, 24;
		D4DBeamBase.IsStep false;
	}
}

Class BFGBeamGZ : Nothing {}
Class BFGBeamLaser : Nothing {}
Class GaussTrail : Nothing {}
Class GaussTrailBig : Nothing {}
Class StaticTrail : Nothing {}
Class StaticTrailBig : Nothing {}
Class TrailBeam : Nothing {}
Class MovingTrailBeam : Nothing {}
Class TrailBeamStaticScalingSpawner : Nothing {}
Class TrailBeamJitterSpawner : Nothing {}
Class LightningTrailBeamV2 : Nothing {}
Class LightningTrailBeamV3 : Nothing {}
Class LightningTrailBeamV4 : Nothing {}
Class LightningBeamV2 : Nothing {}
Class LightningBeamV3 : Nothing {}
Class LaserBeamJitter : Nothing {}
Class WhiteLaserBeamJitter : Nothing {}
Class WhiteLaser : Nothing {}
Class RedLaser : Nothing {}
Class BigRedLaserDrillSMM : Nothing {}
Class BigRedLaserBeamSMM : Nothing {}
Class RedLaserSMM : Nothing {}
Class LanceTrail : Nothing {}
Class VortexTrail : Nothing {}
Class BigRedLaserDrill : Nothing {}
Class BigRedLaserBeamCgunner : Nothing {}
Class RedLaserCgunner : Nothing {}
Class CarrionMergeBeam : Nothing {}
Class CarrionTrailBeam : Nothing {}
Class CarrionTrailBeamMoving : Nothing {}
Class CarrionTrailBeamMovingBoom : Nothing {}
Class BulletTracerFX : Nothing {}
Class BulletTrailBeam : Nothing {}
/*
Class BulletTracerFX : Actor 
{
	const Sparsity = 125.0;
	const Distance = 3.25;
	const Multiplier = 1;
	const SpawnSpeed = 300;
	const TravelTic = Sparsity * 30.0;
	enum BulletTracerFX
	{
		ModelOnly = 		1,
		ParticleOnly =		2,
		ParticleTrail =		3,
		TrailOnly =			4,
	};
	int inv;
	int count;
	int rng;
	int render;
	double dista;
	double distb;
	
	virtual void FaceMoveDir()
	{
		A_FaceTracer();
		//A_FaceMovementDirection();
		//pitch *= -1;
		A_ChangeVelocity(cos(pitch), 0, sin(pitch), CVF_RELATIVE|CVF_REPLACE);
	}
	
	Default 
	{
		+NOINTERACTION
		+NOTONAUTOMAP
		+NOTIMEFREEZE
		RenderStyle "None";
		Speed 1;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay 
		{	
			inv = int(GetCvar("D4D_TracerFX"));
			if (A_CheckSight("Null") || !inv)
			{	return ResolveState("Null");	}
			
			if (tracer) A_FaceTracer(0,0);
			//else FaceMoveDir();
			//FaceMoveDir();
			
			else A_FaceMovementDirection();
			if (inv == ModelOnly)
			{	
				A_SpawnItemEx("BulletSmallTracer",0,0,0,vel.x*200,vel.y*200,vel.z*200,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_ABSOLUTEVELOCITY|SXF_TRANSFERPITCH);
				return ResolveState("Null");	
			}
			
			A_Stop();
			render = int(GetCvar("vid_renderer"));
			count = 1;
			
			if (inv >= TrailOnly)
			{	return ResolveState("B1");	}
			
			A_SpawnParticle("FF8800",SPF_FULLBRIGHT|SPF_RELATIVE,10,4 ,0,cos(pitch)*(Distance*1 ),0,-sin(pitch)*(Distance*1 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FF8F11",SPF_FULLBRIGHT|SPF_RELATIVE,10,5 ,0,cos(pitch)*(Distance*2 ),0,-sin(pitch)*(Distance*2 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FF9822",SPF_FULLBRIGHT|SPF_RELATIVE,10,6 ,0,cos(pitch)*(Distance*3 ),0,-sin(pitch)*(Distance*3 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FF9F33",SPF_FULLBRIGHT|SPF_RELATIVE,10,7 ,0,cos(pitch)*(Distance*4 ),0,-sin(pitch)*(Distance*4 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFA844",SPF_FULLBRIGHT|SPF_RELATIVE,10,8 ,0,cos(pitch)*(Distance*5 ),0,-sin(pitch)*(Distance*5 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFAF55",SPF_FULLBRIGHT|SPF_RELATIVE,10,9 ,0,cos(pitch)*(Distance*6 ),0,-sin(pitch)*(Distance*6 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFB866",SPF_FULLBRIGHT|SPF_RELATIVE,10,10,0,cos(pitch)*(Distance*7 ),0,-sin(pitch)*(Distance*7 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFBF77",SPF_FULLBRIGHT|SPF_RELATIVE,10,10,0,cos(pitch)*(Distance*8 ),0,-sin(pitch)*(Distance*8 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFC888",SPF_FULLBRIGHT|SPF_RELATIVE,10,11,0,cos(pitch)*(Distance*9 ),0,-sin(pitch)*(Distance*9 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFCF99",SPF_FULLBRIGHT|SPF_RELATIVE,10,11,0,cos(pitch)*(Distance*10),0,-sin(pitch)*(Distance*10),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFD8AA",SPF_FULLBRIGHT|SPF_RELATIVE,10,12,0,cos(pitch)*(Distance*11),0,-sin(pitch)*(Distance*11),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFDFBB",SPF_FULLBRIGHT|SPF_RELATIVE,10,12,0,cos(pitch)*(Distance*12),0,-sin(pitch)*(Distance*12),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFE8CC",SPF_FULLBRIGHT|SPF_RELATIVE,10,12,0,cos(pitch)*(Distance*13),0,-sin(pitch)*(Distance*13),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFEFDD",SPF_FULLBRIGHT|SPF_RELATIVE,10,13,0,cos(pitch)*(Distance*14),0,-sin(pitch)*(Distance*14),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFF8EE",SPF_FULLBRIGHT|SPF_RELATIVE,10,13,0,cos(pitch)*(Distance*15),0,-sin(pitch)*(Distance*15),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFFFFF",SPF_FULLBRIGHT|SPF_RELATIVE,10,13,0,cos(pitch)*(Distance*16),0,-sin(pitch)*(Distance*16),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			
			if (inv == ParticleOnly)
			{	return ResolveState("Null");	}

			if (!IsPointerEqual(TracerPtr,NullPtr))
			{	distb = Clamp(GetDistance(true,TracerPtr),0.0,3000.0);	}
			else
			{	distb = 0;	}
			
			return ResolveState("B1");
		}
	B1:
		TNT1 A 1;
	Break:
		TNT1 A 1 
		{
			if (count > 14 || A_CheckSight("Null") || (pos.z < floorz) || (pos.z > ceilingz) ) 
			{	return ResolveState("Null");	} // Destroy it.
			dista = 0;
			return ResolveState(null); //Play out the tic.
		}
	Looping:	// Spawns the trail.
		TNT1 A 0
		{
			// If running GZDoom, spawn the neat trail.
			if (render)
			{
				if (dista <= 0.0)
				{	dista = 64.0;	}
				A_SpawnItemEx("BulletTrailBeam",cos(pitch)*dista,0,-sin(pitch)*dista,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH);
				dista += Sparsity;
			}
			else //Otherwise, do the ol' fashion particles.
			{
				A_SpawnParticle("FFE99E",SPF_FULLBRIGHT|SPF_RELATIVE,100,random(3,6),0,
					cos(pitch)*dista,0,-sin(pitch)*dista,
					frandom(1.0,2.0),0,0,
					-0.005,0,0.005,
					frandom(0.5,1.0),frandom(0.06,0.12));
				
				dista += frandom(3.0,6.0);
			}
			
			if (distb > 0.0)
			{
				if (dista > distb)
				{	return ResolveState("Null");	}
				return ResolveState("Looping");
			}
			else if (dista >= TravelTic)
			{
				count++;
				A_Warp(DefPtr,cos(pitch)*TravelTic,0,-sin(pitch)*TravelTic,0,WARPF_NOCHECKPOSITION);
				return ResolveState("Break");
			}
			return ResolveState("Looping");
		}
		Loop;
	End:
		TNT1 A 0;
		Stop;
	}
}
*/