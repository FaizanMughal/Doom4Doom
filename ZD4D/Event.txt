#include "ZD4D/HUD.txt"

Class D4bum : D4Zombieman
{
}

enum ERestrictFlags
{
	RF_NONE =			0,
	RF_NOHEALTH = 		1,
	RF_NOARMOR = 		1 << 1,	//2
	RF_NOBULLETS =		1 << 2,	//4
	RF_NOSHELLS =		1 << 3,	//8
	RF_NOROCKETS =		1 << 4,	//16
	RF_NOCELLS =		1 << 5,	//32
	RF_NOBFGAMMO =		1 << 6,	//64
	RF_NOCARRION =		1 << 7,	//128
	RF_NOCREDITS =		1 << 8,	//256
	RF_NOCRATES =		1 << 9,	//512
	RF_NOUPGRADES =		1 << 10, //1024	- Has no effect in credit mode.
	
	RF_NOCURRENCY = (RF_NOCREDITS|RF_NOCRATES),	
	RF_NOREGAMMO = (RF_NOBULLETS|RF_NOSHELLS|RF_NOROCKETS|RF_NOCELLS),
	RF_NOSPECAMMO = (RF_NOBFGAMMO|RF_NOCARRION),
	RF_NOAMMO = (RF_NOREGAMMO|RF_NOSPECAMMO),
	
	RF_NOPINATAS = (RF_NOHEALTH|RF_NOARMOR|RF_NOAMMO),
	RF_NOTHING = (RF_NOPINATAS|RF_NOCURRENCY|RF_NOUPGRADES)
};

Class D4Restriction play
{
	Class<Actor> mo;
	int Restrictions;
	bool parent;
}

extend class D4DHandler
{
	enum EWeaponAmmo
	{
		BFGAmmo = 0,
		ChainsawAmmo = 1
	};
	private bool Spawnable[2];
	const DefaultDropChance = 250;
	const TimeTrigger = 35 * 10;
	bool FirstTime;
	uint Timer;
	Array<Actor> Monsters, DeadMonsters;
	Array<Actor> Tracker;
	Array<D4DBeamBase> Beams;
	Array<D4Restriction> RestrictList;
	D4ManualLootList LootList;
	private int UpgradeMode;
	private int CurrentUpgradeMode;
	
	bool CheckAmmoSpawn(EWeaponAmmo index)			{	return Spawnable[index];	}
	void SetAmmoSpawn(EWeaponAmmo index, bool can) 	{	Spawnable[index] = can; 	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	// Restrictions
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	
	//==========================================================================
	// ClearAllRestrictions
	// 
	// Removes all item drop restrictions.
	//==========================================================================
	void ClearAllRestrictions()
	{
		if (RestrictList.Size() < 1)	return;
		
		
		for (int i = 0; i < RestrictList.Size(); i++)
		{
			D4Restriction res = RestrictList[i];
			if (res) res.Destroy();
		}
		RestrictList.Clear();
	}
	
	//==========================================================================
	// SetRestrictions
	// 
	// Sets restrictions on what a monster can drop when they die.
	// No flags means it will delete whatever context there is that was 
	// previously established.
	//==========================================================================
	
	void SetRestrictions(Class<Actor> mo, int flags, bool parent = false)
	{
		if (!mo)	return;
		bool SizeChanged = false;
		for (int i = 0; i < RestrictList.Size(); i++)
		{
			D4Restriction res = RestrictList[i];
			if (!res)
			{
				SizeChanged = true;
				RestrictList.Delete(i);
				i--;
				continue;
			}
			
			if (res.mo == mo)
			{
				if (flags <= 0)
				{
					SizeChanged = true;
					res.Destroy();
					RestrictList.Delete(i);
					continue; // Just to be safe, make sure there's no duplicates.
				}
				res.Restrictions = flags;
				if (SizeChanged)	RestrictList.ShrinkToFit();
				return;
			}
		}
		if (SizeChanged)	RestrictList.ShrinkToFit();
		// Do nothing if the object isn't found and we want to erase it.
		if (flags <= 0)	
			return;
		
		// None found, so make a new one.
		D4Restriction res = new('D4Restriction');
		res.mo = mo;
		res.Restrictions = flags;
		res.parent = parent;
		RestrictList.Push(res);
	}
	
	//==========================================================================
	// GetRestrictions
	// 
	// Checks for restrictions on monsters and returns the bytes.
	//==========================================================================
	
	int GetRestrictions(Class<Actor> mo)
	{
		if (!mo || RestrictList.Size() < 1)
			return RF_NONE;
		
		int size = RestrictList.Size();
		for (int i = 0; i < RestrictList.Size(); i++)
		{
			D4Restriction res = RestrictList[i];
			if (!res)	continue;
			
			// Check if the class is directly that, or a child, if the parent 
			// boolean is set in the restriction class.
			if ((mo == res.mo) || (res.parent && CheckParent(mo, res.mo)))
			{
				return res.Restrictions;
			}
		}
		return RF_NONE;
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	override void WorldTick()
	{
		// Clear the lists every 10 seconds of null pointers.
		Timer++;
		if (Timer >= TimeTrigger)
		{
			Timer = 0;
			// Go through the lists
			int i = 0;
			for (i = 0; i < Monsters.Size(); i++)		if (!Monsters[i])		{	Monsters.Delete(i); i--;		}
			for (i = 0; i < Beams.Size(); i++)			if (!Beams[i])			{	Beams.Delete(i); i--;			}
			for (i = 0; i < Tracker.Size(); i++) 		if (!Tracker[i])		{	Tracker.Delete(i); i--;			}
			for (i = 0; i < DeadMonsters.Size(); i++)	if (!DeadMonsters[i])	{	DeadMonsters.Delete(i); i--;	}
			
			Monsters.ShrinkToFit();
			Beams.ShrinkToFit();
			Tracker.ShrinkToFit();
			DeadMonsters.ShrinkToFit();
		}
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		for (int i = 0; i < MAXPLAYERS; i++)	KNMInput[i] = 0;
		// If starting a new game, set the upgrade mode appropriately. 
		if (!FirstTime && !e.IsSaveGame && !e.IsReopen)
		{
			CVar Upgrade[2];
			Upgrade[0] = CVar.FindCVar("D4D_UpgradeMode");
			Upgrade[1] = CVar.FindCVar("D4D_CurrentUpgradeMode");
			
			if (Upgrade[0] && Upgrade[1])
			{
				UpgradeMode = Upgrade[0].GetInt();
				Upgrade[1].SetInt(UpgradeMode);
				CurrentUpgradeMode = UpgradeMode;
			}
		}
		FirstTime = true;
	}
	
	// No need to keep track of the old entities anymore.
	override void WorldUnloaded(WorldEvent e)
	{
		Spawnable[BFGAmmo] = false;
		Spawnable[ChainsawAmmo] = false;
		Tracker.Clear();
		Monsters.Clear();
		Beams.Clear();
		DeadMonsters.Clear();
		for (int i = 0; i < MAXPLAYERS; i++)	KNMInput[i] = 0;
	}
	
	clearscope int GetUpgradeMode()	{	return CurrentUpgradeMode;	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	
	override void OnRegister()
	{
		for (int i = 0; i < MAXPLAYERS; i++)	KNMInput[i] = 0;
		LootList = D4ManualLootList.Get();
		if (LootList)
		{
			D4ManualLootParameters Loot;
			/*
			Init function parameters are as follows:
				
			Actor Class
				The name of the class to add.
				
			UpgradeDropChance
				The denominator of the chance to drop an upgrade 
				(1 / UpgradeDropChance).
				
			UpgradeDropAlways
				The number of upgrades that will drop upon death, guaranteed.
				
			CrateDropChance
				The numerator of 256 (CrateDropChance / 256) for each crate to 
				drop, individually.
				
			CrateDropAmount
				The number of crates to roll against the RNG CrateDropChance.
				
				I.e. 3 crates with a CrateDropChance means the RNG will run three 
				times for each.
				
			CrateDropAlways
				Guaranteed dropped crate count.
				
			CashChainsawPinata
				-1 by default. Overrides the chainsaw quadrupling bonus 
				(mastermind & cyberdemon are both 2000).
				
			CashAmount
				The normal amount of cash to drop.
			*/
			
			// This D4bum class (see top of source) will drop a fuckton of crates/cash.
			// Bear in mind, LootList.Add(Loot); must be performed after the 
			// Loot.Init function because Loot is a struct, and LootList's Add 
			// function takes that struct as its parameter. Keeps things clean 
			// and organized.
			Loot.Init("D4bum", -1, 1, 256, 666, 666, 999, 200);	LootList.Add(Loot);
		}
		// Use the ERestrictFlags at the top of the file to set restrictions.
		// Most of them should be self explanatory.
		int LostSoulRestrictions = (RF_NOHEALTH|RF_NOARMOR|RF_NOREGAMMO|RF_NOBFGAMMO|RF_NOUPGRADES);
		SetRestrictions("D4LostSoulNoCash", LostSoulRestrictions, true);
		SetRestrictions("D4OldLostSoulNoCash", LostSoulRestrictions, true);
		Super.OnRegister();
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	// Monster recording, for ease of tracking with lightning gun altfire and bfg
	// so far.
	
	override void WorldThingSpawned(WorldEvent e)
	{
		Actor mo = e.thing;
		
		if (mo is "D4DBeamBase")
		{
			Beams.Push(D4DBeamBase(mo));
			return;
		}
		
		if (mo.bNOINTERACTION || mo.bNOSECTOR || mo.bNOBLOCKMAP || mo.player || 
			mo is "Inventory" || mo is "RandomSpawner")
			return;
		
		if ((mo.bISMONSTER || mo.bSHOOTABLE) && mo.health > 0)
		{
			Monsters.Push(mo);
		
			let mon = D4AbstractMonster(mo);
			if (mon)	mon.Event = self;
		}
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	override void WorldThingRevived(WorldEvent e)
	{
		// Add the monster to the list if not already present.
		Actor mo = e.Thing;
		if (Monsters.Find(mo) >= Monsters.Size())
		{
			DeadMonsters.Delete(DeadMonsters.Find(mo));
			Monsters.Push(mo);
		}
		if (mo && mo.bFRIENDLY && mo is "D4AbstractMonster")
		{
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (!playeringame[i]) continue;
				let plr = players[i].mo;
				if (!plr || plr.CountInv("D4MonsterUpgrader")) continue;
				
				if (plr is "PlayerArchvile")
				{
					mo.species = plr.species;
					mo.bTHRUSPECIES = true;
					mo.bMTHRUSPECIES = true;
				}
			}
		}
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	override void WorldThingDestroyed(WorldEvent e)
	{
		Actor mo = e.Thing;
		if (mo is "Inventory" || mo is "RandomSpawner")	return;
		if (mo.bISMONSTER || mo.bSHOOTABLE)
		{
			Monsters.Delete(Monsters.Find(mo));
			DeadMonsters.Delete(DeadMonsters.Find(mo));
		}
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	override void WorldThingDied(WorldEvent e)
	{
		Actor mo = e.Thing;
		if (!DropPinatas(mo, e.Inflictor)) 
			return;
		
		// Allocate them over to the DeadMonsters array and remove them from 
		// the living.
		if (DeadMonsters.Find(mo) >= DeadMonsters.Size())
		{
			DeadMonsters.Push(mo);
			Monsters.Delete(Monsters.Find(mo));
		}
	}
	
	bool DropPinatas(Actor mo, Actor inf = null)
	{
		// First, make sure it exists and it's a monster.
		// Abort if they're set to not drop anything.
		if (!mo || !mo.bISMONSTER || mo.bNOINTERACTION)	return false;
		int Restrictions = GetRestrictions(mo.GetClass());
		if (Restrictions >= RF_NOTHING)					return true;
		
		D4DropList Pinatas;
		bool Armor[4];		for (int i = 0; i < Armor.Size(); i++)	Armor[i] = false;
		bool HPPin = false;
		bool Bullets = false;
		bool Shells = false;
		bool Cells = false;
		bool Rockets = false;
		bool BFG = false;
		bool CashPower = false;
		int UpgradeDropChance = -1, UpgradeDropAlways = 0;
		int CrateDropChance = 0, CrateDropAmount = 0, CrateDropAlways = 0;
		int CashChainsawPinata = 0;
		int CashAmount = 0;
		
		int CashMul = 1;
		int CrateAmt, CrateDrops;
		int LootDrop = mo.GetCvar("D4D_LootDrop");
		int TotalMul = mo.CountInv("D4MonsterUpgrader");
		
		// Needed because the inventory is based on n + 1 (i.e. uncommon has 1 of the above, rare has 2, etc).
		if (TotalMul > 0)	
		{
			TotalMul++;
			CashMul *= TotalMul;
		}
		else TotalMul = 1;
		int Chance = Max(1,TotalMul);
		
		Vector3 pos = 	mo.pos;
		//int hp = 		mo.health;
		int spawnhp = 	mo.GetSpawnHealth();
		Name mod = 		mo.DamageTypeReceived;
		
		// Drop carrion if enabled and the monster can drop it, and if the
		// monster was gibbed.
		if (MPWeapons) 
		{
			if (!(Restrictions & RF_NOCARRION) &&
				(inf && 
					!inf.bNOEXTREMEDEATH &&
						(inf.bEXTREMEDEATH || 
						inf.DamageType == "Extreme" || 
						inf.DeathType == "Extreme")) ||
				(MOD == 'Extreme' ||
					MOD == 'BerserkKill' || 
					MOD == 'ChainsawKill' || 
					MOD == 'MeleePunch' ||
					MOD == 'GloryKill') ||
				(mo.InStateSequence(mo.CurState, mo.ResolveState("XDeathNoDrops"))) ||
				(mo.InStateSequence(mo.CurState, mo.ResolveState("XDeath"))) ||
				(mo.health < mo.GetGibHealth()))
			{
				Pinatas.AddItem("D4PinataCarrion", 1 * TotalMul);
			}	
		}
		
		// First set up the base multiplier upon damage type when killed.
		if (mod == 'ChainsawPinata')
		{
			CashMul *= 4;
			if (!(Restrictions & RF_NOBULLETS))	Pinatas.AddItem("D4PinataBulletsBig", 	LootDrop ? 4 : 1);
			if (!(Restrictions & RF_NOSHELLS))	Pinatas.AddItem("D4PinataShellsBig", 	LootDrop ? 4 : 1);
			if (!(Restrictions & RF_NOCELLS))	Pinatas.AddItem("D4PinataCellsBig", 	LootDrop ? 5 : 1);
			if (!(Restrictions & RF_NOROCKETS))	Pinatas.AddItem("D4PinataRocketsBig", 	LootDrop ? 3 : 1);
		}
		else if (MOD == 'BerserkKill' || 
				MOD == 'ChainsawKill' || 
				MOD == 'MeleePunch' ||
				MOD == 'GloryKill')
		{
			CashMul *= 2;
			if (LootDrop && !(Restrictions & RF_NOHEALTH))
				Pinatas.AddItem("D4PinataHealth", 5); 
		}
		
		// Now check to see if it's a D4D monster. If so, just use what's given.
		// If not, see if it's a manual loot table.
		// Otherwise, establish a formula based on health.
		let d4m = D4AbstractMonster(mo);
		Class<Actor> thing = mo.GetClass();
		
		//Is it manual? This is defined above (see D4bum example).
		if (LootList && LootList.CheckActor(thing)) 
		{
			// Find the thing and snag its contents, if it has any.
			D4ManualLootParameters Loot;
			LootList.Retrieve(thing, Loot);
			CrateDropChance = 		Loot.CrateDropChance;
			CrateDropAmount = 		Loot.CrateDropAmount;
			CrateDropAlways = 		Loot.CrateDropAlways;
			CashChainsawPinata = 	Loot.CashChainsawPinata;
			CashAmount = 			Loot.CashAmount;
			UpgradeDropChance =		Loot.UpgradeDropChance;
			UpgradeDropAlways =		Loot.UpgradeDropAlways;
		}
		else if (d4m) // Not manually overridden -- D4D monster.
		{
			CrateDropChance = 		d4m.CrateDropChance;
			CrateDropAmount = 		d4m.CrateDropAmount;
			CrateDropAlways = 		d4m.CrateDropAlways;
			CashChainsawPinata = 	d4m.CashChainsawPinata;
			CashAmount = 			d4m.CashAmount;
			UpgradeDropChance =		d4m.UpgradeDropChance;
			UpgradeDropAlways =		d4m.UpgradeDropAlways;
			
		}
		else	// Neither D4D monster nor a manually added one.
		{
			if (CurrentUpgradeMode)
			{
				// For every 1000 health, guarantee a crate.
				// Otherwise, divide the HP by 20 and use that as a base chance.
				CrateDropAlways = int(floor(spawnhp / 1000));
				CrateDropChance = Max(1,spawnhp / 20) * (mo.bBOSS ? 2 : 1);
				if (CrateDropChance > 256)
				{
					CrateDropAmount = CrateDropChance / 256;
				}
			}
			else
			{
				CashAmount = spawnhp / (mo.bBoss ? 12 : 15);
			}
		}
		
		// Now that the monster has been prepared, set up the drop chances for crates.
		if (!CurrentUpgradeMode)	// Credits
		{
			if (CashChainsawPinata > 0 && mod == 'ChainsawPinata')
			{
				CashAmount = CashChainsawPinata;
				CashMul = Max(1, TotalMul); // Only multiply if they are a colored monster.
			}
		}
		else	// Crates
		{
			// Cycle through the drop chances of each, excluding the always
			// dropping. If the chance is within valid ranges, just add to
			// amount that will always be given.
			if (!(Restrictions & RF_NOCRATES))
			{
				CrateDrops = CrateDropAmount * CashMul;
				if (CrateDrops > 0)
				{
					for (int i = 0; i < CrateDrops; i++)
					{
						if (random[drop](1,256) <= CrateDropChance)
							CrateDropAlways++;
					}
				}
			}
			// Drop some upgrades based on chance. UpgradeDropChance is the divisor,
			// inverse of how the crates work. 
			// 0 means no chance. 
			// 1 means guaranteed.
			// 2 means 1/2 chance, etc.
			
			
			if (!(Restrictions & RF_NOUPGRADES))
			{	
				bool Soviet = false;
				for (int i = 0; i < MAXPLAYERS; i++)
				{
					if (!playeringame[i]) continue;
					let plr = players[i].mo;
					if (!plr)	continue;
					
					if (!CashPower && plr.CountInv("PowerD4Money"))
					{
						Chance *= 4;
						CashPower = true;
					}
					
					if (!Soviet && 
					!plr.CountInv("SovietToken") &&
					plr.CountInv("AssaultRifleMod1") &&
					plr.CountInv("AssaultRifleMod2") &&
					plr.CountInv("ChaingunMod1") &&
					plr.CountInv("ChaingunMod2") &&
					plr.CountInv("GaussCannonMod1") &&
					plr.CountInv("GaussCannonMod2") &&
					plr.CountInv("PlasmaRifleMod1") &&
					plr.CountInv("PlasmaRifleMod2") &&
					plr.CountInv("RocketLauncherMod1") &&
					plr.CountInv("RocketLauncherMod2") &&
					plr.CountInv("ShotgunMod1") &&
					plr.CountInv("ShotgunMod2") &&
					plr.CountInv("SSGUpgrade1") &&
					plr.CountInv("SSGUpgrade2") &&
					plr.CountInv("SSGUpgrade3") &&
					plr.CountInv("SSGUpgrade4") &&
					plr.CountInv("PistolUpgradeAutomatic") &&
					plr.CountInv("PistolUpgradeAltDamage") &&
					plr.CountInv("PistolUpgradeAltCharge") &&
					plr.CountInv("PistolUpgradeDamage") &&
					plr.CountInv("PistolUpgradeLance") &&
					plr.CountInv("BFGUpgrade1") &&
					plr.CountInv("BFGUpgrade2") &&
					plr.CountInv("BFGUpgrade3") &&
					plr.CountInv("BFGUpgrade4"))
					{
						Soviet = true;
						mo.A_DropItem("SovietChaingunUpgradePickup");
					}
					
					if (Soviet && CashPower)
						break;
				}
				
				
				bool AllowSleight = (UpgradeDropChance < 0);
				if (AllowSleight)	UpgradeDropChance = DefaultDropChance;
				
				// Black and white monsters always drop an upgrade.
				// White drops 2, black drops 1. This stacks in accumulation
				// with the rest of the drop chances.
				UpgradeDropAlways += Clamp(TotalMul - 5, 0, 2);
				
				if (UpgradeDropChance > 0)
				{
					// Give a slight boost to enemies that are bosses as they're tougher.
					if (AllowSleight && mo.bBOSS)
					{
						if (UpgradeDropChance <= 10)
							UpgradeDropChance /= (mo.bBOSS ? 2 : 1);
						else
							UpgradeDropChance -= 10;
					}
					
					if (Max(1,random[drop](1, (UpgradeDropChance / Chance))) == 1)
						UpgradeDropAlways++;
				}
				
				// If we have something to drop, do it.
				if (UpgradeDropAlways > 0)
				{
					for (int i = 0; i < UpgradeDropAlways; i++)
						mo.A_DropItem("D4UpgradePickupSpawner");
				}
			}
		}
		
		if (CashPower)
			CashMul *= 4;
		
		// Iterate through each player to see who has the highest upgrades.
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (!playeringame[i]) continue;
			let p = players[i].mo;
			if (p)
			{
				// Drop items first.
				if (mod != 'Massacre')
				{
					if (LootDrop)
					{
						if (!(Restrictions & RF_NOARMOR))
						{
							if (mod == 'ChainsawPinata')
							{
								// Armor
								if (!Armor[0] && p.CountInv("D4ArmorCapRaiser") >= 25)
								{
									Armor[0] = true;
									int rng[2];
									rng[0] = random[drop](1,256) > 128 ? 1 : 0;
									rng[1] = random[drop](1,256) > 128 ? 1 : 0;
									Pinatas.AddItem("D4PinataArmor", rng[0] + rng[1]);
								}
								if (!Armor[1] && p.CountInv("D4ArmorCapRaiser") >= 50)
								{
									Armor[1] = true;
									int rng[2];
									rng[0] = random[drop](1,256) > 128 ? 1 : 0;
									rng[1] = random[drop](1,256) > 128 ? 1 : 0;
									Pinatas.AddItem("D4PinataArmor", rng[0] + rng[1]);
								}
								if (!Armor[2] && p.CountInv("D4ArmorCapRaiser") >= 100)
								{
									Armor[2] = true;
									Pinatas.AddItem("D4PinataArmor", 2);
								}
							}
							else 
							{
								if (!Armor[3] && p.CountInv("BasicArmor") < 200 && p.CountInv("D4ArmorCapRaiser") >= 25)	//only if player isnt at full armor and has upgraded his armor
								{
									Armor[3] = true;
									int rng = random[drop](1,256) > 192 ? 1 : 0;
									Pinatas.AddItem("D4PinataArmor", rng); //very rarely they will drop armor
								}
							}
						}
						//health giver
						if (!HPPin && !(Restrictions & RF_NOHEALTH) && p.health < 60)
						{
							HPPin = true;
							int rng = random[drop](1,256) > 192 ? 1 : 0;
							Pinatas.AddItem("D4PinataHealth", 1 + rng);
						}
						if (!(Restrictions & RF_NOREGAMMO))
						{
							//bullets giver
							if (!Bullets && !(Restrictions & RF_NOBULLETS) && 
								(p.CountInv("D4AssaultRifle") || 
								p.CountInv("D4Chaingun") ||
								p.CountInv("D4Repeater")) && 
								p.CountInv("D4Bullets") < 10)
							{
								Bullets = true;
								int rng[2];
								rng[0] = random[drop](1,256) > 128 ? 1 : 0;
								rng[1] = random[drop](1,256) > 240 ? 1 : 0;
								Pinatas.AddItem("D4PinataBullets", rng[0] + rng[1]);
							}
							
							//Shells giver
							if (!Shells && !(Restrictions & RF_NOSHELLS) &&
								(p.CountInv("D4Shotgun") || 
								p.CountInv("D4SuperShotgun")) && 
								p.CountInv("D4Shells") < 5)
							{
								Shells = true;
								int rng[2];
								rng[0] = random[drop](1,256) > 128 ? 1 : 0;
								rng[1] = random[drop](1,256) > 128 ? 1 : 0;
								Pinatas.AddItem("D4PinataShells", rng[0] + rng[1]);
							}
							
							//Cells giver
							if (!Cells && !(Restrictions & RF_NOCELLS) &&
								(p.CountInv("D4PlasmaRifle") ||
								p.CountInv("D4GaussCannon") ||
								p.CountInv("D4LightningGun")) && 
								p.CountInv("D4Cells") < 16)
							{
								Cells = true;
								int rng[2];
								rng[0] = random[drop](1,256) > 128 ? 1 : 0;
								rng[1] = random[drop](1,256) > 128 ? 1 : 0;
								Pinatas.AddItem("D4PinataCells", rng[0] + rng[1]);
							}
							//Rockets giver
							if (!Rockets && !(Restrictions & RF_NOROCKETS) &&
								(p.CountInv("D4RocketLauncher") || 
								p.CountInv("D4GrenadeLauncher")) &&
								p.CountInv("D4Rockets") < 5)
							{
								Rockets = true;
								int rng = random[drop](1,256) > 196 ? 1 : 0;
								Pinatas.AddItem("D4PinataRockets", rng);
							}
						}
						//BFG ammo giver, this one doesnt check for low ammo, but it does check for the weapon
						if (!BFG && !(Restrictions & RF_NOBFGAMMO) && p.CountInv("D4BFG"))
						{
							BFG = true;
							if (random[drop](1,512) < 16)	Pinatas.AddItem("D4PinataBFG", 1);
						}
					}
				}
				
				// -------------------------------------------------------------
				// Drop the cash.
				// -------------------------------------------------------------
				// Crates
				if (CurrentUpgradeMode)
				{
					if (!(Restrictions & RF_NOCRATES) && CrateDropAlways > 0)
					{	// The multiplier is already calculated above so do nothing else.
						p.A_GiveInventory("D4DCash",		CrateDropAlways);
						p.A_GiveInventory("D4DCashFake",	CrateDropAlways);
						p.A_GiveInventory("CashUpdater",	1);
					}
				}
				else // Credits
				{
					if (!(Restrictions & RF_NOCREDITS) && CashAmount > 0)
					{
						int OldMul = CashMul;
						CashMul *= p.CountInv("PowerD4Money") ? 4 : 1;
						int CPB1 = p.CountInv("CashPercentBonus");
						int CPB2 = p.CountInv("CashPercentBonusTemp");
						
						double CashAmtPercent = CashAmount * (CPB1 + CPB2);
						CashAmount = (CashAmount + (CashAmtPercent / 100)) * CashMul;
						p.A_GiveInventory("D4DCash",		CashAmount);
						p.A_GiveInventory("D4DCashFake",	CashAmount);
						p.A_GiveInventory("CashUpdater",	1);
						CashMul = oldmul;
					}
				}
			}
		}
		
		if (TotalMul > 0)	
			Pinatas.Multiply(TotalMul);
		Pinatas.DropItemsPos(pos);
		return true;
	}
	
	//--------------------------------------------------------------------------
	// Custom functions
	//--------------------------------------------------------------------------
	static clearscope bool CheckParent(Class<Object> child, Class<Object> parent)
	{
		if (!child)	return false;
		while (true)
		{
			let check = child.GetParentClass();
			if (child == null || check == null)
				return (parent == null) ? true : false;
			if (check == parent)
				return true;
			child = child.GetParentClass();
		}
		return false;
	}
	
	void DestroyBeams(Actor caller)
	{
		if (caller && Beams.Size() > 0)
		{
			for (int i = 0; i < Beams.Size(); i++)
			{
				Actor mo = Beams[i];
				if (mo && (mo.Master == caller) && !mo.bNODAMAGE)
				{
					mo.bNODAMAGE = true;
					mo.SetStateLabel('Death');
				}
			}
		}
	}
	
	void AddTracker(Actor mo)
	{
		if (!mo)	return;
		if (Tracker.Size() < 1 || Tracker.Find(mo) >= Tracker.Size())
			Tracker.Push(mo);
	}
	
	void RemoveTracker(Actor mo)
	{
		if (!mo || Tracker.Size() < 1)	return;
		Tracker.Delete(Tracker.Find(mo));
	}
}

//------------------------------------------------------------------------------
//
//
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
//
//
//------------------------------------------------------------------------------

Struct D4ManualLootParameters
{
	private bool initialized;
	Class<Actor> mo;
	int UpgradeDropChance, UpgradeDropAlways;
	int CrateDropChance, CrateDropAmount, CrateDropAlways;
	int CashChainsawPinata, CashAmount;

	void Init(Class<Actor> th = null, int upchance = -1, int updrop = 0, int cdchance = 0, int cdamt = 0, int cddrop = 0, int ccp = 0, int ca = 0)
	{
		mo = th;
		UpgradeDropChance = upchance;
		UpgradeDropAlways = updrop;
		CrateDropChance = cdchance;
		CrateDropAmount = cdamt;
		CrateDropAlways = cddrop;
		CashChainsawPinata = ccp;
		CashAmount = ca;
		initialized = true;
	}
	
	bool CheckInit()
	{
		return initialized;
	}
}

//------------------------------------------------------------------------------

Class D4ManualLootList : Thinker
{
	Array<Class<Actor> > Actors;
	Array<Int> CrateDropChance, CrateDropAmount, CrateDropAlways;
	Array<Int> CashAmount, CashChainsawPinata;
	Array<Int> UpgradeDropChance, UpgradeDropAlways;
	
	bool CheckActor(Class<Actor> mo)
	{
		int size = Actors.Size();
		return (mo && (size > 0) && (Actors.Find(mo) < size));
	}
	
	int GetSize()
	{
		return Actors.Size();
	}
		
	//--------------------------------------------------------------------------
	// Adds an actor to the list of overrides for modders usage.
	void Add(in D4ManualLootParameters Loot)
	{
		if (!Loot.CheckInit())
		{
			Console.Printf("Error: D4ManualLootParameters must call Init() function before use!");
			return;
		}
		Class<Actor> check = Loot.mo;
		if (!check)	
		{
			Console.Printf("Error: %s is not a proper actor. Check spelling!", Loot.mo);
			return;
		}
		
		// If we already have an actor, just update it. No need to be bloating
		// arrays relentlessly, that'll just cause memory management issues.
		int size = Actors.Size();
		if (size > 0)
		{
			int i = Actors.Find(Loot.mo);
			if (i < size)
			{
				CrateDropChance[i] = Loot.CrateDropChance;
				CrateDropAmount[i] = Loot.CrateDropAmount;
				CrateDropAlways[i] = Loot.CrateDropAlways;
				CashAmount[i] = Loot.CashAmount;
				CashChainsawPinata[i] = Loot.CashChainsawPinata;
				UpgradeDropChance[i] = Loot.UpgradeDropChance;
				UpgradeDropAlways[i] = Loot.UpgradeDropAlways;
				return;
			}
		}
		
		// The actor doesn't exist, so it's all clear to add it to the array.
		Actors.Push(Loot.mo);
		CrateDropChance.Push(Loot.CrateDropChance);
		CrateDropAmount.Push(Loot.CrateDropAmount);
		CrateDropAlways.Push(Loot.CrateDropAlways);
		CashAmount.Push(Loot.CashAmount);
		CashChainsawPinata.Push(Loot.CashChainsawPinata);
		UpgradeDropChance.Push(Loot.UpgradeDropChance);
		UpgradeDropAlways.Push(Loot.UpgradeDropAlways);
	}
	
	//--------------------------------------------------------------------------
	// Removes an actor and associated reservations.
	bool Remove(Class<Actor> mo)
	{
		if (!mo)	return false;
		
		int size = Actors.Size();
		if (size > 0)
		{
			int i = Actors.Find(mo);
			if (i < size)
			{
				Actors.Delete(i);
				CrateDropChance.Delete(i);
				CrateDropAmount.Delete(i);
				CrateDropAlways.Delete(i);
				CashAmount.Delete(i);
				CashChainsawPinata.Delete(i);
				UpgradeDropChance.Delete(i);
				UpgradeDropAlways.Delete(i);
				return true;
			}
		}
		return false;
	}
	
	//--------------------------------------------------------------------------
	// Retrieves the data.
	void Retrieve(Class<Actor> mo, in out D4ManualLootParameters Loot)
	{
		int size = Actors.Size();
		if (size > 0)
		{
			int i = Actors.Find(mo);
			if (i < size)
			{
				Loot.Init	(Actors[i], 
							UpgradeDropChance[i], 
							UpgradeDropAlways[i], 
							CrateDropChance[i], 
							CrateDropAmount[i], 
							CrateDropAlways[i], 
							CashChainsawPinata[i], 
							CashAmount[i]);
			}
		}
	}

	//--------------------------------------------------------------------------
	// Initializer stuff. Don't touch.
	D4ManualLootList Init()
	{
		CrateDropChance.Clear();
		CrateDropAmount.Clear();
		CrateDropAlways.Clear();
		CashAmount.Clear();
		CashChainsawPinata.Clear();
		UpgradeDropChance.Clear();
		UpgradeDropAlways.Clear();
		ChangeStatNum(STAT_STATIC);
		return self;
	}

	static D4ManualLootList Get()
	{
		ThinkerIterator it = ThinkerIterator.Create("D4ManualLootList",STAT_STATIC);
		let p = D4ManualLootList(it.Next());
		if (p == null)
		{
			p = new("D4ManualLootList").Init();
		}
		return p;
	}
}

//==============================================================================
//==============================================================================
//
//	Base items
//
//==============================================================================
//==============================================================================

// Defines how many pinatas to drop.

Struct D4DropList play
{
	Array<Class<Inventory> > ItemName;
	Array<Int> ItemCount;
	Array<Double> ItemAmountMul;
	
	//--------------------------------------------------------------------------
	// ResetList()
	//
	// Wipes out all items on the drop list and sets all counts to 0.
	//--------------------------------------------------------------------------
	
	void ResetList()
	{
		ItemName.Clear();
		ItemCount.Clear();
		ItemAmountMul.Clear();
	}
	
	//--------------------------------------------------------------------------
	// AddItem(actor, count, amount, adding?)
	//
	// Adds an item to the list and how many to spawn.
	//--------------------------------------------------------------------------
	
	void AddItem(Class<Inventory> newthing, int count = 1, double amountMul = 1.0, 
				bool adding = true, int res = 0)
	{
		// Don't bother if the value is 0. 
		if (count == 0) 
			return;
			
		// Make sure the item's valid first.
		if (!newthing)
		{
			Console.Printf("Error: %s is not a valid item!", newthing);
			return;
		}
		// Search the array first for something, if its size is > 0. Otherwise,
		// add it in if not found.
		int size = ItemName.Size();
		if (size > 0)
		{
			int i = ItemName.Find(newthing);
			if (i < size)
			{
				ItemCount[i] = adding ? ItemCount[i] + count : count;
				
				if (amountMul > 0.0)
					ItemAmountMul[i] = Max(1.0, amountMul);
				return;
			}
		}
		ItemName.Push(newthing);
		ItemCount.Push(count);
		ItemAmountMul.Push(Max(1.0, amountMul));
	}
	
	//--------------------------------------------------------------------------
	// Multiply(amount)
	// 
	// Multiplies the amount on all drops.
	//--------------------------------------------------------------------------
	
	void Multiply(double amt)
	{
		if (amt <= 0.0)	return;
		
		if (ItemAmountMul.Size() > 0)
		{
			for (int i = 0; i < ItemAmountMul.Size(); i++)
				ItemAmountMul[i] *= amt;
		}
	}
	
	//--------------------------------------------------------------------------
	// DropItemsPos(actor)
	//
	// Causes an actor to spawn its entire list of items.
	//--------------------------------------------------------------------------
	
	void DropItemsPos(Vector3 mpos)
	{
		int size = ItemName.Size();
		if (size > 0)
		{
			for (int i = 0; i < size; i++)
			{
				Class<Inventory> check = ItemName[i];
				if (check == null)	continue;
				for (int j = 0; j < ItemCount[i]; j++)
				{
					Inventory it = Inventory(Actor.Spawn(check, mpos + (0, 0, 32)));
					
					if (it)
					{
						it.bTHRUACTORS = true;
						it.amount = int(it.amount * ItemAmountMul[i]);
						it.bTHRUACTORS = false;
						it.VelFromAngle(frandom[a](3,6),random[a](0,359));
						it.vel.Z += frandom[a](1,5);
						it.A_FaceMovementDirection(0,0);
						
					}
				}
			}
			ItemName.Clear();
			ItemCount.Clear();
		}
	}
}