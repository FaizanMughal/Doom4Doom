
enum PinataConstants
{	
	PinataLifetime = 			175 + DelayVacuum, 
	PinataLifetimeLong = 		700 + DelayVacuum, 
	PinataLifetimeSuperLong = 	4200 + DelayVacuum, //2 minutes
	RadiusPull = 				192,
	DelayVacuum =				20,
	PSpeed = 					24,
	VelFlags =					CVF_RELATIVE|CVF_REPLACE,
};

//==============================================================================
//==============================================================================
//
// Pinata pickups
//
//==============================================================================
//==============================================================================

//------------------------------------------------------------------------------
// The base of all pinatas.
// Contains all the work for determining
//------------------------------------------------------------------------------
Class D4PinataBase : Actor
{
	enum BorderTypes
	{
		Border_RegAmmo = 	Fr_D,
		Border_BFGAmmo =	Fr_H,
		Border_Armor =		Fr_A,
		Border_Health =		Fr_B
	};
	
	enum ETypes
	{
		Pinata_Ammo = 0,
		Pinata_Health,
		Pinata_Armor
	};
	D4PinataParticles Border;
	int SeekDelay;
	Color Trail;
	Inventory Pickup;
	// Armor specific
	
	// General properties
	
	int						MainType, CR, CG, CB, Amount, MaxAmount, 
							BorderFrame, Lifetime;
	double 					MagnetDistance;
	bool					Magnetic, AlwaysPickup, IgnoreSkill;
	Class<Inventory>		BaseType;
	
	Property IgnoreSkill:	IgnoreSkill;
	Property AlwaysPickup:	AlwaysPickup;
	Property Lifetime:		Lifetime;
	Property Amount:		Amount;
	Property MaxAmount:		MaxAmount;
	Property MainType: 		MainType;
	Property BaseType: 		BaseType;
	Property Magnetic: 		Magnetic;
	Property Distance:		MagnetDistance;
	Property TrailColor:	CR, CG, CB;
	
	Default
	{
		D4PinataBase.IgnoreSkill false;
		D4PinataBase.AlwaysPickup false;
		D4PinataBase.Lifetime PinataLifetime;
		D4PinataBase.Amount 1;
		D4PinataBase.MaxAmount -1;
		D4PinataBase.TrailColor -1, -1, -1;
		D4PinataBase.MainType Pinata_Ammo;
	//	D4PinataBase.BaseType "D4Bullets";
		D4PinataBase.Magnetic true;
		D4PinataBase.Distance RadiusPull;
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
		BounceFactor 0.5;
		Damage 0;
		Projectile;
		+PAINLESS
		+BRIGHT
		-NOGRAVITY
		+NOBLOCKMONST
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		+CANBOUNCEWATER
		-BOUNCEAUTOOFF
		+SKYEXPLODE
		+SEEINVISIBLE
	}
	
	//==========================================================================
	// Overrides
	//==========================================================================
	/*
	override void BeginPlay()
	{
		Amt = Amount;
		MaxAmt = MaxAmount;
		Super.BeginPlay();
	}
	*/
	override void OnDestroy()
	{
		if (Border)	Border.Destroy();
		Super.OnDestroy();
	}
	override void PostBeginPlay()
	{
		if (MainType == Pinata_Ammo && (!BaseType || BaseType.GetParentClass() != "Ammo"))
		{	Destroy(); return;	}
			
		if (!BaseType)
		{
			Switch (MainType)
			{
				Case Pinata_Health:	BaseType = "D4Stimpack"; break;
				Case Pinata_Armor:	BaseType = "D4ArmorBasePickup"; break;
				Default: break;
			}			
		}
		
		Super.PostBeginPlay();
		Setup();
	}
	
	override void Tick()
	{
		if (!bNOTIMEFREEZE && (level.frozen || globalfreeze))
			return;
		
		if (SeekDelay > 0)	SeekDelay--;
		Super.Tick();
	}
	
	override int SpecialMissileHit(Actor victim)
	{
		if (!BaseType || !victim || !victim.bPICKUP || victim.health < 1) 
			return 1;
		// Pass through all but the tracer which will pick this thing up.
		
		if (SeekDelay)	Tracer = victim;
		
		let inv = Inventory(Spawn(BaseType, Tracer.pos));
		if (inv)
		{
			let arm = D4ArmorBasePickup(inv);
			if (arm)
			{
				arm.SaveAmount = Amount;
				if (MaxAmount > -1)	arm.MaxSaveAmount = MaxAmount;
			}
			else
			{
				inv.Amount = Amount;
				if (MaxAmount > -1)	inv.MaxAmount = MaxAmount;
			}
			inv.bDROPPED = true;
			inv.ClearCounters();
			if (AlwaysPickup)	inv.bALWAYSPICKUP = true;
			if (IgnoreSkill)	Inv.bIGNORESKILL = true;
			// Did it touch? Picked up?
			inv.Touch(Tracer);
			if (inv.bPICKUPGOOD)
			{	
				// Return contact and destroy this object.
				bTHRUACTORS = bNOINTERACTION = true;
				return 0;
			}
			// If not, destroy the item.
			inv.Destroy();
		}
		return 1;
	}
	
	//==========================================================================
	// Custom Functions
	//==========================================================================
	
	//-------------------------------------------------------------------------
	//  
	Actor FindPlayer(int distance = -1, Actor mo = null)
	{
		if (distance <= 0) distance = RadiusPull;
		
		// First check for a player to pull towards. If none is supplied,
		// find one.
		
		bool InfPickup = (sv_unlimited_pickup || AlwaysPickup);
		if (!mo || mo.health < 1 || !mo.bPICKUP)
		{
			mo = null;
			double dist = MagnetDistance;
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (!playeringame[i])	
					continue;
				
				Actor plr = players[i].mo;
				if (!plr || plr.health < 1 || !plr.bPICKUP)
					continue;
					
				double curdist = Distance3DSquared(plr);
				if (curdist > dist ** 2)
					continue;
				//--------------------------------------------------------------
				// Now we need to check for what type.
				
				if (MainType == Pinata_Ammo && BaseType)
				{
					if (!InfPickup)
					{
						let inv = plr.FindInventory(BaseType, true);
						if (inv && inv.Amount >= inv.MaxAmount)
							continue;
					}
				}
				else if (MainType == Pinata_Health)
				{
					let pl = PlayerPawn(plr);
					if (!pl || pl.Health >= pl.GetMaxHealth(true))
						continue;
				}
				else if (MainType == Pinata_Armor)
				{
					if (!InfPickup)
					{
						let inv = BasicArmor(plr.FindInventory("BasicArmor",true));
						if (inv && inv.Amount >= inv.MaxAmount)
							continue;
					}
				}
				else return null;
				
				//--------------------------------------------------------------
				dist = curdist;
				mo = plr;
			}
			return mo;
		}
		else if (MainType == Pinata_Ammo && BaseType)
		{
			if (!InfPickup)
			{
				let inv = mo.FindInventory(BaseType, true);
				if (inv && inv.Amount >= inv.MaxAmount)
					return null;
			}
		}
		else if (MainType == Pinata_Health)
		{
			let pl = PlayerPawn(mo);
			if (!pl || pl.Health >= pl.GetMaxHealth(true))
				return null;
		}
		else if (MainType == Pinata_Armor)
		{
			if (!InfPickup)
			{
				let inv = BasicArmor(mo.FindInventory("BasicArmor",true));
				if (inv && inv.Amount >= inv.MaxAmount)
					return null;
			}
		}
		else return null;
		
		return mo;
	}
	
	//--------------------------------------------------------------------------
	void Setup()
	{
		SeekDelay = DelayVacuum;
		Switch (MainType)
		{
			Case Pinata_Armor:	BorderFrame = Frame = Fr_A;	Trail = "00FF00";	break;
			Case Pinata_Health:	BorderFrame = Frame = Fr_B;	Trail = "29C9FF";	break;
			Default:
			{
				Trail = "FFED29";
				BorderFrame = Frame = Fr_D;
				
				if (BaseType == "D4Bullets")
				{ 	break;	}
				else if (BaseType == "D4Carrion")
				{	Trail = "FF2846";	A_SetTranslation("CarrionBorder");	}
				else if (BaseType == "D4Shells")
					Frame = Fr_E;
				else if (BaseType == "D4Cells")
					Frame = Fr_F;
				else if (BaseType == "D4Rockets")
					Frame = Fr_G;
				else if (BaseType == "D4BFGAmmo")
				{
					BorderFrame = Frame = Fr_H;
					Trail = "00FF00";
				}
				break;
			}
		}
		
		// If a custom trail color is defined, use that.
		if (CR >= 0 && CG >= 0 && CB >= 0)
		{
			CR = Clamp(CR, 0, 255);
			CG = Clamp(CG, 0, 255);
			CB = Clamp(CB, 0, 255);
			Trail = Color(255, CR, CG, CB);
		}
	}
	
	States
	{
	Precache:
		PIN2 A 0;
		PIN3 A 0;
	Spawn:
		---- A 0 NoDelay
		{
			Border = D4PinataParticles(Spawn("D4PinataParticles", pos, ALLOW_REPLACE));
			if (Border)
			{
				Border.Master = self;
				Border.NoSetup = true;
				Border.PT = Trail;
				Border.frm = BorderFrame;
			}
		}
	Looking:
		---- A 2
		{
			if (Magnetic)	
			{
				Tracer = FindPlayer(-1, Tracer);				
			}
			
			if (Tracer)
			{
				Lifetime = Default.Lifetime;
				Alpha = 1.0;
				bNOGRAVITY = true;
				double dist = Distance3DSquared(Tracer);
				double mdist = Max(1, Tracer.Height, Tracer.Radius) ** 2;
				
				if (dist <= mdist * 2)
				{
					if (dist <= mdist)
					{
						bNOINTERACTION = false;
						Warp(Tracer, 0, 0, 0, 0, WARPF_NOCHECKPOSITION|WARPF_USECALLERANGLE, 0.5);
					}
					else
					{
						bNOINTERACTION = (!CheckSight(Tracer, SF_IGNOREVISIBILITY|SF_IGNOREWATERBOUNDARY|SF_SEEPASTSHOOTABLELINES));
					}
					
				}
				else
				{
					bNOINTERACTION = false;
					A_Face(Tracer, 0.001, 0, 0, 0, FAF_MIDDLE);
					
					Vel3DFromAngle(PSpeed, AngleTo(Tracer), pitch);
				}
				
			}
			else if (Lifetime-- < 1)
			{
				bNOGRAVITY = bNOINTERACTION = false;
				Lifetime = 0;
				A_FadeOut();
			}
		}
		Wait;
	Death:
		TNT1 A 1;
		Stop;
	}
}

Class D4PinataParticles : Actor 
{
	Color PT;
	Vector3 oldpos;
	int frm, cv;
	bool NoSetup;
	enum PinataParticleBorder
	{
		CV_Border = 			0,
		CV_BorderParticle = 	1,
		CV_Particle = 			2,
		CV_None = 				3,
		
		CV_ParticleBorder = 	CV_BorderParticle,
		Distance = 				200,
		Increment = 			4
	};
	
	Default 
	{
		Radius 1;
		Height 1;
		+NOINTERACTION
		+NOTONAUTOMAP
		+BRIGHT
		+FORCEXYBILLBOARD
		+SEEINVISIBLE
		Scale 0.3;
		DistanceCheck "D4D_MaxDrawDistance";
	}
	
	override void PostBeginPlay() 
	{	
		if (!master)
		{	Destroy(); return;	}
		Super.PostBeginPlay();
		cv = GetCvar("D4D_PinataParticles");
		ChangeTID(0);
		
		if (NoSetup)
			return;
			
		Class<Actor> cls = master.GetClass();
		
		if (cls == "D4PinataArmor")
		{	PT = "00FF00";	frm = 0;	}
		else if (master is "D4BFGAmmo")
		{	PT = "00FF00";	frm = 7;	}
		else if (cls == "D4PinataCarrion")
		{	PT = "FF2846";	frm = 3;	A_SetTranslation("CarrionBorder");	}
		else if (cls == "D4PinataHealth")
		{	PT = "29C9FF";	frm = 1;	}
		else
		{	PT = "FFED29";	frm = 3;	}
	}
	
	// Credit to TheZombieKiller for this. <3
	void SpawnPinataParticleLine(Color c, double units, Vector3 pointA, Vector3 pointB)
	{
		//if (pointA == pointB)	return;
		// get a vector pointing from A to B
		let pointAB = pointB - pointA;
		
		// get distance
		let dist = pointAB.Length();
		
		// normalize it
		pointAB /= dist;
		
		// iterate in units of "units" parameter
		for (double i = 1; i <= dist; i += units)
		{
			// we can now use 'pointA + i * pointAB' to
			// get a position that is 'i' units away from
			// pointA, heading in the direction towards pointB
			let position = i * pointAB;
			A_SpawnParticle(c,SPF_FULLBRIGHT,25,8,0,position.x,position.y,position.z);
		}
	}
		
	States
	{
	Spawn:
		PIN3 A 0 NoDelay { Frame = frm; }
	Looping:
		"####" "#" 1
		{
			if (!master)
				return Destroy();
			
			if (cv == CV_Border || cv == CV_BorderParticle)
			{
				bINVISIBLE = (cv == CV_Particle);
				Warp(Master,0,0,5,0,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_COPYVELOCITY);
				
				if ((cv == CV_BorderParticle || cv == CV_Particle))
				{	
					SpawnPinataParticleLine(PT, 4.0, master.pos - master.vel, master.pos);
				}
			}
			else
			{	bINVISIBLE = true; A_SetTics(35);	}
		}
		Loop;
	}
}

Struct PlrCheck play
{
	//--------------------------------------------------------------------------
	static void SetFlying (Actor who, bool enabled)
	{
		if (!who) return;
		
		who.bNOINTERACTION = who.bNOCLIP = enabled;
		who.A_ChangeLinkFlags(enabled);
	}
	//--------------------------------------------------------------------------
	// Checks if the freeze cheat or powerup is active.
	static bool CheckTimeFreeze()
	{	return (globalfreeze || level.Frozen);	}
	
	//-------------------------------------------------------------------------
	// Checks if the pinata and/or upgrade is near a player that's not morphed 
	// and alive. 
	static Actor CheckForPlayers(Actor checkee, int distance = -1)
	{
		if (!checkee)	return null;
		Actor trc = checkee.tracer;
		if (trc)
		{
			if (trc is "PlayerPawn" && !trc.FindInventory("PowerMorph",true) &&
				trc.health > 0 && trc.player)
			{
				if (!(trc.player.cheats & (CF_NOCLIP|CF_NOCLIP2)))
					return trc;
			}
		}
		
		if (distance <= 0) distance = RadiusPull;
		
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				Actor plr = players[i].mo;
				if (plr && !plr.FindInventory("PowerMorph",true) && plr.health > 0 && 
					checkee.Distance3DSquared(plr) <= distance ** 2)
				{
					if (plr.player.cheats & (CF_NOCLIP|CF_NOCLIP2))
						continue;
					return plr;
				}
			}
		}
		return null;
	}
}



/* UpgradePinataFlier
 *
 * Serves as the latest think tank for the pinatas to help reduce code bloat.
 * One can pass in what items to check along with the upgrades that supplement
 * the check to ensure it's eligible for picking up.
 * 
 * I.e. 
 */

Class UpgradePinataFlier : Thinker
{
	Actor 				Spawner;			// The main actor to move and monitor.
	PlayerPawn			Target;				// The target to fly after.
	Class<Inventory> 	Item;				// The item to check for < max
	Class<Inventory>	Condition;			// Other item to check
	int					Distance;
	int					Conditional; 		// Amount of the conditional to add on
	int 				MaxAmt;				// Max Amount
	bool 				NoUnlimited;		// Ignore unlimited pickup cvar?
	bool				DestroyMe;			// Destroy on the next tic.
	bool				NoItem;				// For upgrades.
	private bool		IsHealth;			// Special treatment required.
	private int			OddTic;
	
	override void PostBeginPlay()
	{
		if (Distance == 0)	Distance = -1;
		// Strictly enforce conditions for health.
		if (Item && Item == 'Health')
		{
			NoUnlimited = IsHealth = true;
			Condition = null;
			Conditional = 0;
			NoItem = false;
			
		}
		Super.PostBeginPlay();
	}
	
	override void Tick()
	{
		if (DestroyMe || !Spawner || (!NoItem && !Item))
		{	Destroy(); return;	}
			
		Inventory it = Inventory(Spawner);
		if (!it || it.Owner)
		{	Destroy(); return;	}
		
		OddTic = (OddTic + 1) % 2;
		
		if (PlrCheck.CheckTimeFreeze() || !OddTic)	
			return;
		
		Target = PlayerPawn(PlrCheck.CheckForPlayers(Spawner, Distance));
		int Amt = 0;
		if (Target && !NoItem)
		{
			if (IsHealth)
			{
				Amt = Target.health;
				MaxAmt = Target.GetMaxHealth(true);
			}
			else	
				Amt = Target.CountInv(Item) + (Condition ? Target.CountInv(Condition) : 0);
				
			if ((NoUnlimited || !sv_unlimited_pickup) && Amt >= MaxAmt)
				Target = null;
		}
		
		// Will pass in the player that's eligible for this item.
		Spawner.tracer = Target;
		
		Super.Tick();
	}
}

//---------------------------------
// Pinata Armor
Class D4PinataArmor : D4ArmorBasePickup
{
	UpgradePinataFlier flier;
	int count;	
	bool Flying;
	int Lifetime;
	property Lifetime: Lifetime;
	Default 
	{
		D4ArmorBasePickup.SaveAmount 6;
		D4PinataArmor.Lifetime PinataLifetime;
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		+NOBLOCKMONST
		+SEEINVISIBLE
		+INVENTORY.ALWAYSPICKUP
		BounceFactor 0.5;
		DistanceCheck "D4D_MaxDrawDistance";
		Inventory.PickUpSound "Doom4/Pickups/ArmorShard";
		Inventory.PickupMessage "";
	}
	
	States
	{
	Spawn:
		PIN2 A 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			invoker.flier = new("UpgradePinataFlier");
			if (invoker.flier)
			{
				invoker.flier.Spawner = invoker;
				invoker.flier.Item = "Armor";
				invoker.flier.MaxAmt = 200;
			}
		}
	Looping:
		"----" A 2
		{
			if (invoker.count < DelayVacuum)	{	invoker.count += 2;	return;		}
			// Tracer should automatically be handled by the thinker.
			if (invoker.tracer)
			{
				invoker.count = DelayVacuum;
				PlrCheck.SetFlying(invoker, true);
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
				if (Distance3DSquared(invoker.tracer) <= Max(invoker.tracer.radius, invoker.tracer.height) ** 2)
				{	SetOrigin(invoker.tracer.pos, true); A_Stop(); PlrCheck.SetFlying(invoker, false);	}
			}
			else
			{
				PlrCheck.SetFlying(invoker, false);
				invoker.count += 2;
			}
			
			if (invoker.count > invoker.Lifetime)	A_FadeOut();
			else 									invoker.Alpha = 1.0;
		}
		Loop;
	}
}



//---------------------------------
// Pinata health
Class D4PinataHealth : D4Stimpack
{
	UpgradePinataFlier flier;
	int count;	
	bool Flying;
	int Lifetime;
	property Lifetime: Lifetime;
	Default 
	{
		D4PinataHealth.Lifetime PinataLifetime;
		Inventory.PickUpSound "Doom4/Pickups/Health";
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
		BounceFactor 0.5;
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		+NOBLOCKMONST
		+SEEINVISIBLE
		+NOTELESTOMP
		Inventory.Amount 8;
		DistanceCheck "D4D_MaxDrawDistance";
	}
		
	States
	{
	Spawn:
		PIN2 B 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER,0,Color_Blue);
			flier = new("UpgradePinataFlier");
			if (flier)
			{
				flier.Spawner = self;
				flier.Item = "Health";
			}
		}
	Looping:
		"----" A 2
		{
			if (count < DelayVacuum)	{	count += 2;	return;		}
			// Tracer should automatically be handled by the thinker.
			if (tracer)
			{
				count = DelayVacuum;
				PlrCheck.SetFlying(self, true);
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
				if (Distance3DSquared(invoker.tracer) <= Max(invoker.tracer.radius, invoker.tracer.height) ** 2)
				{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(self, false);	}
			}
			else
			{
				PlrCheck.SetFlying(self, false);
				count += 2;
			}
			
			if (count > Lifetime)	A_FadeOut();
			else 					Alpha = 1.0;
		}
		Loop;
	}
}


//---------------------------------
// Pinata ammo bullets
Class D4PinataBullets : D4Bullets
{
	UpgradePinataFlier flier;
	int count;	
	bool Flying;
	int Lifetime;
	property Lifetime: Lifetime;
	Default 
	{
		D4PinataBullets.Lifetime PinataLifetime;
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
		Inventory.Amount 20;
		Inventory.PickupSound "Doom4/Pickups/AmmoSmall";
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		+NOBLOCKMONST
		+NOTELESTOMP
		+SEEINVISIBLE
		BounceFactor 0.5;
		DistanceCheck "D4D_MaxDrawDistance";
	}
	
	States
	{
	Spawn:
		PIN2 D 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			flier = new("UpgradePinataFlier");
			if (flier)
			{
				flier.Spawner = self;
				flier.Item = "D4Bullets";
				flier.MaxAmt = 250;
			}
		}
	Looping:
		"----" A 2
		{
			if (count < DelayVacuum)	{	count += 2;	return;		}
			// Tracer should automatically be handled by the thinker.
			if (tracer)
			{
				count = DelayVacuum;
				PlrCheck.SetFlying(self, true);
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
				if (Distance3DSquared(invoker.tracer) <= Max(invoker.tracer.radius, invoker.tracer.height) ** 2)
				{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(self, false);	}
			}
			else
			{
				PlrCheck.SetFlying(self, false);
				count += 2;
			}
			
			if (count > Lifetime)	A_FadeOut();
			else 					Alpha = 1.0;
		}
		Loop;
	}
}
Class D4PinataBulletsBig : D4PinataBullets
{
	Default 
	{
		Scale 0.4;
		Inventory.Amount 50;
		Inventory.PickupSound "Doom4/Pickups/AmmoBig";
		DistanceCheck "D4D_MaxDrawDistance";
	}
}

//---------------------------------
// Pinata ammo shells
Class D4PinataShells : D4Shells
{
	UpgradePinataFlier flier;
	int count;	
	bool Flying;
	int Lifetime;
	property Lifetime: Lifetime;
	Default 
	{
		D4PinataShells.Lifetime PinataLifetime;
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
		Inventory.Amount 4;
		Inventory.PickupSound "Doom4/Pickups/AmmoSmall";
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		BounceFactor 0.5;
		+NOBLOCKMONST
		+SEEINVISIBLE
		+NOTELESTOMP
		DistanceCheck "D4D_MaxDrawDistance";
	}
		
	States
	{
	Spawn:
		PIN2 E 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			flier = new("UpgradePinataFlier");
			if (flier)
			{
				flier.Spawner = self;
				flier.Item = "D4Shells";
				flier.MaxAmt = D4Shells_MaxAmount1;
			}
		}
	Looping:
		"----" A 2
		{
			if (count < DelayVacuum)	{	count += 2;	return;		}
			// Tracer should automatically be handled by the thinker.
			if (tracer)
			{
				count = DelayVacuum;
				PlrCheck.SetFlying(self, true);
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
				if (Distance3DSquared(invoker.tracer) <= Max(invoker.tracer.radius, invoker.tracer.height) ** 2)
				{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(self, false);	}
			}
			else
			{
				PlrCheck.SetFlying(self, false);
				count += 2;
			}
			
			if (count > Lifetime)	A_FadeOut();
			else 					Alpha = 1.0;
		}
		Loop;
	}
}


Class D4PinataShellsBig : D4PinataShells
{
	Default 
	{
		Scale 0.4;
		Inventory.Amount 8;
		Inventory.PickupSound "Doom4/Pickups/AmmoBig";
	}
}



//---------------------------------
// Pinata ammo cells
Class D4PinataCells : D4Cells
{
	UpgradePinataFlier flier;
	int count;	
	bool Flying;
	int Lifetime;
	property Lifetime: Lifetime;
	Default 
	{
		D4PinataCells.Lifetime PinataLifetime;
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
		Inventory.Amount 20;
		Inventory.PickupSound "Doom4/Pickups/AmmoSmall";
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		BounceFactor 0.5;
		+NOBLOCKMONST
		+SEEINVISIBLE
		+NOTELESTOMP
	}
	States
	{
	Spawn:
		PIN2 F 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			flier = new("UpgradePinataFlier");
			if (flier)
			{
				flier.Spawner = self;
				flier.Item = "D4Cells";
				flier.MaxAmt = D4Cells_MaxAmount1;
			}
		}
	Looping:
		"----" A 2
		{
			if (count < DelayVacuum)	{	count += 2;	return;		}
			// Tracer should automatically be handled by the thinker.
			if (tracer)
			{
				count = DelayVacuum;
				PlrCheck.SetFlying(self, true);
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
				if (Distance3DSquared(invoker.tracer) <= Max(invoker.tracer.radius, invoker.tracer.height) ** 2)
				{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(self, false);	}
			}
			else
			{
				PlrCheck.SetFlying(self, false);
				count += 2;
			}
			
			if (count > Lifetime)	A_FadeOut();
			else 					Alpha = 1.0;
		}
		Loop;
	}
}
Class D4PinataCellsBig : D4PinataCells
{
	Default 
	{
		Scale 0.4;
		Inventory.Amount 40;
		Inventory.PickupSound "Doom4/Pickups/AmmoBig";
	}
}

//---------------------------------
// Pinata ammo rockets
Class D4PinataRockets : D4Rockets
{
	UpgradePinataFlier flier;
	int count;	
	bool Flying;
	int Lifetime;
	property Lifetime: Lifetime;
	Default 
	{
		D4PinataRockets.Lifetime PinataLifetime;
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
		Inventory.Amount 3;
		Inventory.PickupSound "Doom4/Pickups/AmmoSmall";
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		BounceFactor 0.5;
		+NOBLOCKMONST
		+SEEINVISIBLE
		+NOTELESTOMP
	}
	
	States
	{
	Spawn:
		PIN2 G 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			flier = new("UpgradePinataFlier");
			if (flier)
			{
				flier.Spawner = self;
				flier.Item = "D4Rockets";
				flier.MaxAmt = D4Rockets_MaxAmount1;
			}
		}
	Looping:
		"----" A 2
		{
			if (count < DelayVacuum)	{	count += 2;	return;		}
			// Tracer should automatically be handled by the thinker.
			if (tracer)
			{
				count = DelayVacuum;
				PlrCheck.SetFlying(self, true);
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
				if (Distance3DSquared(invoker.tracer) <= Max(invoker.tracer.radius, invoker.tracer.height) ** 2)
				{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(self, false);	}
			}
			else
			{
				PlrCheck.SetFlying(self, false);
				count += 2;
			}
			
			if (count > Lifetime)	A_FadeOut();
			else 					Alpha = 1.0;
		}
		Loop;
	}
}
Class D4PinataRocketsBig : D4PinataRockets
{
	Default 
	{
		Scale 0.4;
		Inventory.Amount 6;
		Inventory.PickupSound "Doom4/Pickups/AmmoBig";
	}
}


//---------------------------------
// Pinata ammo BFG

Class D4PinataBFG : D4BFGAmmo
{
	UpgradePinataFlier flier;
	int count;	
	bool Flying;
	int Lifetime;
	property Lifetime: Lifetime;
	Default 
	{
		D4PinataBFG.Lifetime PinataLifetimeLong;
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		BounceFactor 0.5;
		+NOBLOCKMONST
		+SEEINVISIBLE
		+NOTELESTOMP
	}
	
	States
	{
	Spawn:
		PIN2 H 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER,0,Color_Green);
			flier = new("UpgradePinataFlier");
			if (flier)
			{
				flier.Spawner = self;
				flier.Item = "D4BFGAmmo";
				flier.MaxAmt = D4BFGAmmo_MaxAmount;
			}
		}
	Looping:
		"----" A 2
		{
			if (count < DelayVacuum)	{	count += 2;	return;		}
			// Tracer should automatically be handled by the thinker.
			if (tracer)
			{
				count = DelayVacuum;
				PlrCheck.SetFlying(self, true);
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
				if (Distance3DSquared(invoker.tracer) <= Max(invoker.tracer.radius, invoker.tracer.height) ** 2)
				{	SetOrigin(tracer.pos, true); A_Stop(); PlrCheck.SetFlying(self, false);	}
			}
			else
			{
				PlrCheck.SetFlying(self, false);
				count += 2;
			}
			
			if (count > Lifetime)	A_FadeOut();
			else 					Alpha = 1.0;
		}
		Loop;
	}
}

//=======================================================================
//=======================================================================
// Special drops for zombieman, shotgunguy and chaingunner
//=======================================================================
//=======================================================================

//*********************************
// zombieman
Class D4PinataBulletsZombieman : D4Bullets	//only dropped by these guys, and they dont go after player
{
	int count;
	Default 
	{
		Scale 0.3;
		Radius 8;
		Height 16;
		Inventory.Amount 10;
		Inventory.PickupSound "Doom4/Pickups/AmmoSmall";
		BounceType "Doom";
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		BounceFactor 0.5;
		+NOBLOCKMONST
		+SEEINVISIBLE
		+NOTELESTOMP
	}
	States
	{
	Spawn:
		PIN2 D 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
		}
	Looping:
		"----" A 2
		{
			if (A_CheckFloor("Null"))	{	return ResolveState("Landed");	}
			return ResolveState(null);
		}
		Loop;
	Landed:
		"####" "#" 1
		{
			count++;
			if (count > PinataLifetimeLong)
			{	return ResolveState("Fading");		}
			return ResolveState(null);
		}
		Loop;
	Fading:
		"####" "#" 1 A_FadeOut();
		Wait;
	}
}


Class D4PinataShellsShotgunGuy : D4Shells	//only dropped by these guys, and they dont go after player
{
	int count;
	Default 
	{
		Scale 0.3;
		Radius 8;
		Height 16;
		Inventory.Amount 8;
		Inventory.PickupSound "Doom4/Pickups/AmmoSmall";
		BounceType "Doom";
		+BRIGHT
		+BOUNCEONFLOORS
		+BOUNCEONWALLS
		+BOUNCEONCEILINGS
		BounceFactor 0.5;
		+NOBLOCKMONST
		+SEEINVISIBLE
		+NOTELESTOMP
	}
	States
	{
	Spawn:
		PIN2 E 0 NoDelay 
		{
			A_SpawnItemEx("D4PinataParticles",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
		}
	Looping:
		"----" A 2
		{
			if (A_CheckFloor("Null"))	{	return ResolveState("Landed");	}
			return ResolveState(null);
		}
		Loop;
	Landed:
		"####" "#" 1
		{
			count++;
			if (count > PinataLifetimeLong)
			{	return ResolveState("Fading");		}
			return ResolveState(null);
		}
		Loop;
	Fading:
		"####" "#" 1 A_FadeOut();
		Wait;
	}
}

Class D4PinataBulletsChaingunGuy : D4PinataBulletsZombieman	//only dropped by these guys, and they dont go after player
{
	
	Default 
	{ Inventory.Amount 10; }
}




//---------------------------------
// Le cash!
// Unused.

Class D4Cash : Actor 
{
	Default 
	{
		Scale 0.3;
		Radius 8;
		Height 16;
		Gravity 0.4;
	}
	States
	{
	Spawn:
		PINA C 1 NODELAY Bright
		{
			A_SpawnParticle("999999",SPF_FULLBRIGHT,35,3);
			if(A_CheckFloor("Null"))
			{
				return ResolveState("Landed");
			}
			return ResolveState(null);
		}
		Loop;
	Landed:
		PINA C -1 Bright;
		Stop;
	}
}