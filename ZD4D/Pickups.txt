enum PickupConstants
{
	//Armor Per Difficulty
	ArmorCapGreen =				100,
	ArmorCapBlue =				200,
	ArmorCapGreenNormal =		100,	//UV
	ArmorCapGreenNightmare =	100,		//Nightmare
	ArmorCapGreenUltra =		100,		//Ultra Nightmare
	ArmorCapBlueNormal =		200,
	ArmorCapBlueNightmare =		200,
	ArmorCapBlueUltra =			200,
	
	ArmorGreenNormal =		100,	//UV
	ArmorGreenNightmare =	75,		//Nightmare
	ArmorGreenUltra =		50,		//Ultra Nightmare
	ArmorBlueNormal =		200,
	ArmorBlueNightmare =	150,
	ArmorBlueUltra =		100,
	

	PinataLifetime = 			175 + DelayVacuum, 
	PinataLifetimeLong = 		700 + DelayVacuum, 
	PinataLifetimeSuperLong = 	4200 + DelayVacuum, //2min
	RadiusPull = 				192,
	DelayVacuum =				20,
	PSpeed = 					24,
	VelFlags =					CVF_RELATIVE|CVF_REPLACE,
};

//=======================================================================
//=======================================================================
// Health
//=======================================================================
//=======================================================================

Class D4Stimpack : Health replaces Stimpack
{	
	Default 
	{
		Inventory.PickupMessage "Small health";
		Inventory.Amount 10;
		Inventory.PickUpSound "Doom4/Pickups/Health";
		DistanceCheck "user_MaxDrawDistance";
		Scale 0.5;
	}
	States
	{
	Spawn:
		D4HL A -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

Class D4Medikit : Health replaces Medikit
{	
	Default 
	{
		Inventory.PickupMessage "Big health";
		Inventory.PickUpSound "Doom4/Pickups/Health";
		Inventory.Amount 30;
		Scale 0.5;
		DistanceCheck "user_MaxDrawDistance";
	}
	States
	{
	Spawn:
		D4HL B -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

Class D4HealthBonus : HealthBonus replaces HealthBonus
{	
	Default 
	{
		Inventory.PickUpSound "Doom4/Pickups/HealthBonus";
		Scale 0.55;
		Inventory.Amount 3;
		DistanceCheck "user_MaxDrawDistance";
	}
	States
	{
	Spawn:
		D4HL C -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

// This should never be spawned.
Class D4HealthBonusUpgraded : D4HealthBonus
{
	Default
	{
		+INVENTORY.IGNORESKILL
		Inventory.MaxAmount 300;
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	}
}

//=======================================================================
//=======================================================================
// Armor
//=======================================================================
//=======================================================================

Class D4ArmorPickup : BasicArmorPickup replaces BasicArmorPickup
{	
	Default 
	{
		DistanceCheck "user_MaxDrawDistance";
		Armor.SavePercent 100;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
	}
}

Class D4BasicArmorBonus : BasicArmorBonus replaces BasicArmorBonus
{
	Default 
	{
		DistanceCheck "user_MaxDrawDistance";
		Armor.SavePercent 100;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
	}
}

Class D4ArmorBonus : ArmorBonus replaces ArmorBonus
{
	Default 
	{
		Armor.SavePercent 100;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
		DistanceCheck "user_MaxDrawDistance";
		Inventory.PickUpSound "Doom4/Pickups/ArmorShard";
		Armor.SaveAmount 3;
		Scale 0.55;
		+ALLOWPAIN 
	}
	States
	{
	Spawn:
		D4AR B -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	}
}

Class ArmorStripper : CustomInventory
{
	Default 
	{
		+INVENTORY.ALWAYSPICKUP
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			A_TakeInventory("Armor",32767);
			A_TakeInventory("ArmorBonus",32767);
			A_TakeInventory("BasicArmor",32767);
			A_TakeInventory("BasicArmorBonus",32767);
			A_TakeInventory("BasicArmorPickup",32767);
			A_TakeInventory("D4ArmorBonus",32767);
			A_TakeInventory("D4GreenArmor",32767);
			A_TakeInventory("D4BlueArmor",32767);
			A_TakeInventory("D4BasicArmorBonus",32767);
			A_TakeInventory("D4ArmorBonus",32767);
			A_TakeInventory("D4ArmorPickup",32767);
			A_TakeInventory("D4BlueArmorMegasphere",32767);
			return true;
		}
		Stop;
	}
}

Class D4GreenArmorGiver : ArmorBonus
{
	Default 
	{
		+INVENTORY.ALWAYSPICKUP
		Armor.SavePercent 100;
		Armor.SaveAmount 100;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
	}
}

Class D4GreenArmor100 : D4GreenArmorGiver { Default { +INVENTORY.IGNORESKILL }}

Class D4BlueArmorGiver : ArmorBonus
{
	Default 
	{
		+INVENTORY.ALWAYSPICKUP
		Armor.SavePercent 100;
		Armor.SaveAmount 200;
		Armor.MaxAbsorb 200;
		Armor.MaxFullAbsorb 200;
	}
}

// Allow me to explain wtf is going on here...
// When it comes to syphon armor and the regular armor pickup, the two just
// did not get along well. So I came up with a system utilizing CustomInventory
// to do the measuring instead, and voila! Problem solved. It can now be picked
// up at any time while wearing any kind of armor, provided the armor is lower
// than the specified amount.

Class ArmorCount : Inventory { Default { Inventory.MaxAmount 200;	Inventory.InterhubAmount 0; }}

Class ArmorSinglePoint : D4ArmorBonus
{
	Default 
	{
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.IGNORESKILL
		Armor.SaveAmount 1;
	}
}

Class D4GreenArmor : CustomInventory replaces GreenArmor
{
	Default 
	{
		Inventory.PickUpSound "Doom4/Pickups/Armor";
		Inventory.PickUpMessage "Big Armor Chunk";
		DistanceCheck "user_MaxDrawDistance";
		Scale 0.5;
	}
	States
	{
	Spawn:
		D4AR C -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	Pickup:
		TNT1 A 0
		{ // See top of file for armor cap definitions.
			if (CountInv("BasicArmor") < ArmorCapGreen + CountInv("D4ArmorCapRaiser"))
			{
				A_TakeInventory("ArmorCount",32767);
				if (CountInv("BasicArmor"))
				{	A_GiveInventory("ArmorCount",CountInv("BasicArmor"));	}
				if (A_GiveInventory("ArmorStripper",1))
				{
					while (CountInv("ArmorCount"))
					{
						A_GiveInventory("ArmorSinglePoint",1);
						A_TakeInventory("ArmorCount",1,0);
					}
					A_GiveInventory("D4GreenArmorGiver",1);	
					
					if (CountInv("BasicArmor") > ArmorCapGreen + CountInv("D4ArmorCapRaiser"))
					{
						A_GiveInventory("ArmorStripper");
						A_GiveInventory("D4GreenArmor100");
						
						while (CountInv("BasicArmor") < ArmorCapGreen + CountInv("D4ArmorCapRaiser"))
						{
							A_GiveInventory("ArmorSinglePoint",1);
						}
					}
					
				}
				return true;
			}
			return false;
		}
		Stop;
	}
}

Class D4BlueArmor : CustomInventory replaces BlueArmor
{
	Default 
	{
		Inventory.PickUpSound "Doom4/Pickups/Armor";
		Inventory.PickUpMessage "Full Armor Casing";
		DistanceCheck "user_MaxDrawDistance";
		Scale 0.75;
	}
	States
	{
	Spawn:
		D4AR A -1 NODELAY A_SetAngle(random(0,359));
		Stop;
	Pickup:
		TNT1 A 0
		{
			if (CountInv("BasicArmor") < ArmorCapBlue)
			{
				A_TakeInventory("ArmorCount",32767);
				if (CountInv("BasicArmor"))
				{	A_GiveInventory("ArmorCount",CountInv("BasicArmor"));	}
				if (A_GiveInventory("ArmorStripper",1))
				{
					while (CountInv("ArmorCount"))
					{
						A_GiveInventory("ArmorSinglePoint",1);
						A_TakeInventory("ArmorCount",1,0);
					}
					A_GiveInventory("D4BlueArmorGiver",1);
					
				}
				return true;
			}
			return false;
		}
		Stop;
	}
}


//=======================================================================
//=======================================================================
// Backpack
//=======================================================================
//=======================================================================
Class D4Backpack : BackpackItem replaces Backpack 
{
	int user_rangle;
	Default 
	{
		Scale 0.7;
		Inventory.PickupMessage "Picked up a backpack";
		Height 26;
	}
	States
	{
	Spawn:
		BPAK A -1 NoDelay
		{
			user_rangle = random(0,359);
			
			A_SetAngle(user_rangle);
			
			if (!CountInv("FragGrenadePickup",Player1))
			{
				A_SpawnItemEx("FragGrenadeWorld",0,0,0,0,0,0,user_rangle,SXF_NOCHECKPOSITION|SXF_ABSOLUTEANGLE);
				
			}
			else if (!CountInv("HoloGrenadePickup",Player1))
			{
				A_SpawnItemEx("HoloGrenadeWorld",0,0,0,0,0,0,user_rangle,SXF_NOCHECKPOSITION|SXF_ABSOLUTEANGLE);
				
			}
			else if (!CountInv("SyphonGrenadePickup",Player1))
			{
				A_SpawnItemEx("SyphonGrenadeWorld",0,0,0,0,0,0,user_rangle,SXF_NOCHECKPOSITION|SXF_ABSOLUTEANGLE);
			}
		}
		Stop;
	}
}

//==============================================================================
//==============================================================================
// Upgrades Made Manifest
//==============================================================================
//==============================================================================

Class D4UpgradePickupSpawner : Actor
{
	Array<String> items;
	override void PostBeginPlay()
	{
		Actor tt = tracer;
		A_TransferPointer(Player1,DefPtr,DefPtr,TracerPtr,4);
		let plr = PlayerPawn(tracer);
		
		if (!plr || !plr.player)
		{
			A_Log("ERROR: Couldn't find player!");
			Destroy();
			return;
		}
		tracer = tt;
		
		Class<Inventory> ItemToSpawn = null;
		int BigRNG = random(1,3);
		
		//======================================================================
		// Suit + Powerups
		//======================================================================
		if (BigRNG > 1)
		{
			Actor temp = tracer;
			A_TransferPointer(Player1,DefPtr,DefPtr,TracerPtr,4);
			let plr = PlayerPawn(tracer);
			tracer = temp;
			
			if (plr)
			{
				items.Clear();
				if (BigRNG > 2)
				{
					if (!plr.CountInv("D4MegachargeUpgrade1") || !plr.CountInv("D4MegachargeUpgrade2"))
						items.Push("D4MegachargeUpgradePickup");
					if (!plr.CountInv("D4DoomDollUpgrade1") || !plr.CountInv("D4DoomDollUpgrade2"))
						items.Push("D4DoomDollUpgradePickup");
					if (!plr.CountInv("D4RegenUpgrade1") ||
						!plr.CountInv("D4RegenUpgrade2") ||
						!plr.CountInv("D4RegenUpgrade3") ||
						!plr.CountInv("D4RegenUpgrade4"))
						items.Push("D4RegenUpgradePickup");
				}
				else
				{
					if (!plr.CountInv("D4AirControl"))					items.Push("D4AirControlUpgradePickup");
					if (plr.Stamina < 100)								items.Push("D4HealthUpgradePickup");
					if (plr.CountInv("D4ArmorCapRaiser") < 100)			items.Push("D4ArmorUpgradePickup");
					//if (plr.CountInv("CashPercentBonus") < 40)			items.Push("D4CashUpgradePickup");
					if (plr.CountInv("D4CrateUpgrade") < 3)				items.Push("D4CrateUpgradePickup");
					if (!plr.CountInv("ProtectionBonus3"))				items.Push("D4ProtectionUpgradePickup");
				}
			}
			if (items.Size() < 1)	BigRNG = 1;
			else
			{
				int size = items.Size() - 1;
				Class<Inventory> check = items[random(0,size)];
				
				if (!check)	
					BigRNG = 1;
				else
				{
					let ItemToSpawn = Actor(Spawn(check,pos));
					if (ItemToSpawn)
					{
						ItemToSpawn.vel = vel;
						ItemToSpawn.target = target;
						ItemToSpawn.master = master;
						ItemToSpawn.tracer = tracer;
						return Destroy();
					}
				}
			}
		}
		//======================================================================
		// Weapons
		//======================================================================
		if (BigRNG == 1) 
		{
			// Weapons must be on the leftmost side. All upgrades must follow.
			int ToAdd = 6;
			static const Class<Inventory> weap[] =
			{
				"D4Pistol",			"PistolUpgradeAutomatic",	"PistolUpgradeAltDamage",	"PistolUpgradeAltCharge",	"PistolUpgradeDamage",		"PistolUpgradeLance",
				"D4Shotgun", 		"ShotgunMod1",				"ShotgunMod2",				null,						null,						null,
				"D4SuperShotgun", 	"SSGUpgrade1",				"SSGUpgrade2",				"SSGUpgrade3",				"SSGUpgrade4",				null,
				"D4Repeater", 		"RepeaterUpgradePiercing",	"RepeaterUpgradeDamage",	"RepeaterUpgradeAltDamage",	"RepeaterUpgradeAltAmmo",	null,
				"D4AssaultRifle", 	"AssaultRifleMod1",			"AssaultRifleMod2",			null,						null,						null,
				"D4Chaingun", 		"ChaingunMod1",				"ChaingunMod2",				null,						null,						null,
				"D4RocketLauncher",	"RocketLauncherMod1",		"RocketLauncherMod2",		null,						null,						null,
				//"D4GrenadeLauncher",null,						null,						null,						null,						null, 
				"D4PlasmaRifle", 	"PlasmaRifleMod1",			"PlasmaRifleMod2",			null,						null,						null,
				"D4LightningGun", 	"LGUpgradeAmmo",			"LGUpgradeRange",			"LGUpgradeDamage",			"LGUpgradeAltFire",			null,
				"D4StaticRifle", 	"StaticUpgrade1",			"StaticUpgrade2",			"StaticUpgrade3",			"StaticUpgrade4",			null,
				"D4VortexRifle", 	"VortexUpgradeDamage",		"VortexUpgradeAmmo",		"VortexUpgradeAltSpeed",	"VortexUpgradeAltPierce",	null,
				"D4GaussCannon", 	"GaussCannonMod1",			"GaussCannonMod2",			null,						null,						null,
				"D4BFG",			"BFGUpgrade1",				"BFGUpgrade2",				"BFGUpgrade3",				"BFGUpgrade4",				null,
				"D4CarrionCannon",	"CarrionUpgradePickup",		"CarrionUpgradeAmmo",		"CarrionUpgradeStun",		"CarrionUpgradeTime",		null
			};
			
			static const bool chainset[] =
			{
				true,	//pistol
				true,	//shotgun
				true,	//ssg
				false,	//repeater
				true,	//har
				true,	//chaingun
				true,	//rl
				true,	//plasma
				false,	//lightning
				false,	//static
				false,	//vortex
				true,	//gauss
				true,	//bfg
				false	//carrion
			};
			
			Class<Inventory> OwnedWeaps[20];
			uint owned = 0, l = 0;
			int filled = 0;
			for (uint i = 0; i < weap.Size(); i += ToAdd)
			{
				int maxfill = 0, cnt = 0;
				
				// If they have the weapon, check to see if they have all the
				// upgrades. Increment maxfill by all applicable upgrades that
				// exist, and increment cnt only by what the player has.
				
				// If the player still has more to go, add that weapon to the
				// pool chance of random droppers.
				if (weap[i] && plr.CountInv(weap[i]))
				{
					bool chaincount = chainset[l];	l++;	// UAC Russia represents.
					
					for (int j = 1; j < ToAdd; j++)
					{
						if (weap[i + j] != null)
						{
							maxfill++;
							cnt += CountInv(weap[i + j],Player1) ? 1 : 0;
						}
					}
					
					//Increment only whenever there is more to be gained.
					if (cnt < maxfill)
					{
						OwnedWeaps[owned] = weap[i];
						owned++;
					}
					else if (chaincount)
					{
						filled++;
					}
				}
			}
			
			// The weapons needed for the soviet chaingun have all been filled.
			// Spawn it in addition to whatever else will spawn as a bonus reward.
			if (filled >= 9)
			{
				let soviet = Actor(Spawn("SovietChaingunUpgradePickup",pos));
				if (soviet)	
				{
					soviet.vel = vel;
					soviet.target = target;
					soviet.master = master;
					soviet.tracer = tracer;
				}
			}
			
			if (owned < 1)
			{
				// Nothing to do here. 
				Destroy();
				return;
			}
			
			// Now backtrack since n-1 is needed.
			owned--;
			int rng = random(0,owned);
			
			// Spawn it and GTFO.
			if (OwnedWeaps[rng])
			{
				static const Class<Inventory> weapup[] =
				{
					"D4Pistol",			"PistolUpgradePickup",
					"D4Shotgun", 		"ShotgunUpgradePickup",
					"D4SuperShotgun", 	"SuperShotgunUpgradePickup",
					"D4Repeater", 		"RepeaterUpgradePickup",
					"D4AssaultRifle", 	"AssaultRifleUpgradePickup",
					"D4Chaingun", 		"ChaingunUpgradePickup",
					"D4RocketLauncher", "RocketLauncherUpgradePickup",
					//"D4GrenadeLauncher", },
					"D4PlasmaRifle", 	"PlasmaRifleUpgradePickup",
					"D4LightningGun", 	"LightningGunUpgradePickup",
					"D4StaticRifle", 	"StaticRifleUpgradePickup",
					"D4VortexRifle", 	"VortexRifleUpgradePickup",
					"D4GaussCannon", 	"GaussCannonUpgradePickup",
					"D4BFG",			"BFGUpgradePickup",
					"D4CarrionCannon",	"CarrionCannonUpgradePickup"
				};
				
				for (uint k = 0; k < weapup.Size(); k += 2)
				{
					if (k % 1 != 0)	k--;	// Never be odd. Even only.
					if (OwnedWeaps[rng] == weapup[k])
					{
						if ((k + 1 <= weapup.Size()) && (k + 1 > 0))
						{
							ItemToSpawn = weapup[k+1];
							if (!ItemToSpawn)
							{
								// Die.
								Destroy();
								return;
							}
							break;
						}
					}
				}
			}
			
			let upitem = Actor(Spawn(ItemToSpawn,pos));
			if (upitem) 
			{
				upitem.vel = vel;
				upitem.target = target;
				upitem.master = master;
				upitem.tracer = tracer;
			}
		}
		Destroy();
		return;		
	}
	
	Default
	{
		+NOINTERACTION
	}
}

//==============================================================================
// Powerups
//==============================================================================

Class D4PowerUpgradePickup : CustomInventory
{
	int count;
	int ticker;
	bool Flying;
	Array<String> items;
	Default
	{
		+INVENTORY.ALWAYSPICKUP
		+BRIGHT
	}
	States
	{
	Spawn:
		M670 F 17;
		M671 F 17;
		"----" A 1
		{
			invoker.ticker = (invoker.ticker + 1) % 34;
			
			if (invoker.ticker < 17)
				sprite = GetSpriteIndex("M670");
			else
				sprite = GetSpriteIndex("M671");
				
			if (invoker.count >= DelayVacuum)
			{
				PlrCheck.CheckForPlayers(self);
				if (tracer && (invoker.Flying || Distance3D(tracer) <= RadiusPull))
				{
					bNOCLIP = bNOINTERACTION = true;
					A_FaceTracer(0,0,0,0,FAF_MIDDLE);
					A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
					if (GetDistance(true,TracerPtr) <= 32)
					{
						A_Warp(TracerPtr,0,0,16,0,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_STOP);
						bNoclip = false;
						bNoInteraction = false;
						A_ChangeLinkFlags(false);
					}
				}
			}
			else invoker.count++;
		}
		Wait;
	Pickup:
		TNT1 A 0;
		Stop;
	}
}

Class D4MegachargeUpgradePickup : D4PowerUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Megacharge Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			invoker.items.Clear();
			if (!CountInv("D4MegachargeUpgrade1"))	invoker.items.Push("D4MegachargeUpgrade1");
			if (!CountInv("D4MegachargeUpgrade2"))	invoker.items.Push("D4MegachargeUpgrade2");
			
			if (invoker.items.Size() > 0)
			{
				int rng = random(0, invoker.items.Size() - 1);
				Class<Inventory> som = invoker.items[rng];
				if (som)	A_GiveInventory(som);
				A_Print("$"..invoker.items[rng]);
			}
			
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}
Class D4DoomDollUpgradePickup : D4PowerUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Doom Doll Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			invoker.items.Clear();
			if (!CountInv("D4DoomDollUpgrade1"))	invoker.items.Push("D4DoomDollUpgrade1");
			if (!CountInv("D4DoomDollUpgrade2"))	invoker.items.Push("D4DoomDollUpgrade2");
			
			if (invoker.items.Size() > 0)
			{
				int rng = random(0, invoker.items.Size() - 1);
				Class<Inventory> som = invoker.items[rng];
				if (som)	A_GiveInventory(som);
				A_Print("$"..invoker.items[rng]);
			}
			
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}
Class D4RegenUpgradePickup : D4PowerUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Regeneration Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			invoker.items.Clear();
			if (!CountInv("D4RegenUpgrade1"))	invoker.items.Push("D4RegenUpgrade1");
			if (!CountInv("D4RegenUpgrade2"))	
			{
				if (CountInv("D4RegenUpgrade1"))
					invoker.items.Push("D4RegenUpgrade2");
			}
			if (!CountInv("D4RegenUpgrade3"))	invoker.items.Push("D4RegenUpgrade3");
			if (!CountInv("D4RegenUpgrade4"))	invoker.items.Push("D4RegenUpgrade4");
			
			if (invoker.items.Size() > 0)
			{
				int rng = random(0, invoker.items.Size() - 1);
				Class<Inventory> som = invoker.items[rng];
				if (som)	A_GiveInventory(som);
				A_Print("$"..invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

/*
// Template
Class D4UpgradePickup : D4PowerUpgradePickup
{
	Default
	{
		Inventory.PickupMessage " Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (!CountInv(""))
			
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}*/

//==============================================================================
// Suit
//==============================================================================

Class D4SuitUpgradePickup : CustomInventory
{
	int ticker;
	int count;
	bool Flying;
	Default
	{
		+INVENTORY.ALWAYSPICKUP
		+BRIGHT
	}
	States
	{
	Spawn:
		M670 G 17;
		M671 G 17;
		"----" A 1
		{
			invoker.ticker = (invoker.ticker + 1) % 34;
			
			if (invoker.ticker < 17)
				sprite = GetSpriteIndex("M670");
			else
				sprite = GetSpriteIndex("M671");
				
			if (invoker.count >= DelayVacuum)
			{
				PlrCheck.CheckForPlayers(self);
				if (tracer && (invoker.Flying || Distance3D(tracer) <= RadiusPull))
				{
					bNOCLIP = bNOINTERACTION = true;
					A_FaceTracer(0,0,0,0,FAF_MIDDLE);
					A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
					if (GetDistance(true,TracerPtr) <= 32)
					{
						A_Warp(TracerPtr,0,0,16,0,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_STOP);
						bNoclip = false;
						bNoInteraction = false;
						A_ChangeLinkFlags(false);
					}
				}
			}
			else invoker.count++;			
		}
		Wait;
	}
}

Class D4AirControlUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Air Control Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (!CountInv("D4HigherJump"))		
			{	A_SetInventory("D4HigherJump",1);	A_Print("Higher Jump");	}
			else if (CountInv("D4MultiJump") < 3)	
			{	A_SetInventory("D4MultiJump",3);	A_Print("Triple Jump");	}
			else if (!CountInv("D4AirControl"))		
			{	A_SetInventory("D4AirControl",1);	A_Print("Air Control");	}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class D4HealthUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Health Upgrade";
	}
	action void SetStamina(int amt)
	{
		bool given = (stamina < 100);
		A_SetInventory("D4Stamina",amt);
		stamina = amt;
		A_SetHealth(Max(health, 100 + amt));
		
		if (given) A_Print("Max Health +"..amt);
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
				 if (Stamina < 25)		SetStamina(25);
			else if (Stamina < 50)		SetStamina(50);
			else 						SetStamina(100);
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class D4ArmorUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Armor Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			bool given = true;
			int amt = CountInv("D4ArmorCapRaiser");
				 if (amt < 25)		A_SetInventory("D4ArmorCapRaiser",25);
			else if (amt < 50)		A_SetInventory("D4ArmorCapRaiser",50);
			else if (amt < 100)		A_SetInventory("D4ArmorCapRaiser",100);
			else
			{
				given = false;
				if (A_GiveInventory("ArmorStripper",1))
					A_GiveInventory("D4BlueArmorMegasphere",1);
			}
			
			if (given)
			{
				amt = CountInv("D4ArmorCapRaiser");
				String line1 = "Armor Capacity +"..amt.."\n";
				
					 if (amt >= 100)	line1 = line1.."Chainsaw Alt guarantees minimum 2 armor shards";
				else if (amt >= 50)		line1 = line1.."Chainsaw Alt: + 0 to 4 Armor Shards";
				else					line1 = line1.."Chainsaw Alt: + 0 to 2 Armor Shards";
				
				A_Print(line1);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class D4CashUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Credit Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (CountInv("CashPercentBonus") < 40)		
			{
				A_GiveInventory("CashPercentBonus",10);
				int amt = CountInv("CashPercentBonus");
				
				A_Print("Credit Upgrade +"..amt.."%");
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class D4CrateUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Crate Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			int amt = CountInv("D4CrateUpgrade");
			if (amt < 3)		
			{
				A_GiveInventory("D4CrateUpgrade",1);
				
				amt += 1;
					 if (amt == 1)	A_Print("Heavy Crates\nGuarantees larger quality items");
				else if (amt == 2)	A_Print("Sensor Crates\nCrates are more situationally aware");
				else				A_Print("Weapon Crates\nCrates may contain weapons");
				
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class D4ProtectionUpgradePickup : D4SuitUpgradePickup
{
	Default
	{
		Inventory.PickupMessage "Protection Upgrade";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (!CountInv("ProtectionBonus1"))
			{
				A_SetInventory("ProtectionBonus1",1);
				A_Print("50% Environment Damage Reduction");
			}
			else if (!CountInv("ProtectionBonus2"))
			{
				A_SetInventory("ProtectionBonus2",1);
				A_Print("50% Self Damage Reduction");
			}
			else if (!CountInv("ProtectionBonus3"))
			{
				A_SetInventory("ProtectionBonus3",1);
				A_Print("50% Radius Damage Reduction");
			}
			else
			{
				A_PlaySound("PentagramOfProtection/Pickup",CHAN_ITEM,1);
				A_GiveInventory("PentagramOfProtection",1); //Fuck it, why not. :P
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

//==============================================================================
// Weapon Upgrades
//==============================================================================

Class D4UpgradePickup : CustomInventory
{
	Class<Inventory> items[10];	
	String desc[5];
	uint index;
	int ticker;
	int count;
	bool Flying;
	int frm;
	name s1, s2;
	property Frame: frm;
	override void PostBeginPlay()
	{
		
		if (GetClass() == "D4UpgradePickup")
		{
			Destroy();
			return;
		}
		angle = random(0,359);
		bTHRUACTORS = false;
		Super.PostBeginPlay();
	}
	Default
	{
		+INVENTORY.ALWAYSPICKUP
		+BRIGHT
	}
	
	States
	{
	Spawn:
		"----" A 1
		{
			invoker.ticker = (invoker.ticker + 1) % 34;
			
			if (invoker.ticker < 17)
				sprite = GetSpriteIndex("M668");
			else
				sprite = GetSpriteIndex("M669");
				
			frame = invoker.frm;
				
			if (invoker.count >= DelayVacuum)
			{
				PlrCheck.CheckForPlayers(self);
				if (tracer && (invoker.Flying || Distance3D(tracer) <= RadiusPull))
				{
					bNOCLIP = bNOINTERACTION = true;
					A_FaceTracer(0,0,0,0,FAF_MIDDLE);
					A_ChangeVelocity(cos(pitch)*PSpeed,0,-sin(pitch)*PSpeed,CVF_RELATIVE|CVF_REPLACE);
					if (GetDistance(true,TracerPtr) <= 32)
					{
						A_Warp(TracerPtr,0,0,16,0,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_STOP);
						bNoclip = false;
						bNoInteraction = false;
						A_ChangeLinkFlags(false);
					}
				}
			}
			else invoker.count++;
		}
		Wait;
	}
}


Class PistolUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 1;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"PistolUpgradeAutomatic",	
				"PistolUpgradeAltDamage",	
				"PistolUpgradeAltCharge",	
				"PistolUpgradeDamage",
				"PistolUpgradeLance"	};
			
			static const String itemstr[] =
			{	"$PistolUpgradeAutomatic",	
				"$PistolUpgradeAltDamage",	
				"$PistolUpgradeAltCharge",	
				"$PistolUpgradeDamage",
				"$PistolUpgradeLance"	};
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					if (itemnames[i] == "PistolUpgradeLance" && 
						(!CountInv("PistolUpgradeAltDamage") || !CountInv("PistolUpgradeAltCharge")))
						continue;
						
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class ShotgunUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 2;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"ShotgunMod1",	"ShotgunMod2"	};
			
			static const String itemstr[] =
			{	"$ShotgunMod1",	"$ShotgunMod2"	};
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class SuperShotgunUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 3;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"SSGUpgrade1",	"SSGUpgrade2",	"SSGUpgrade3",	"SSGUpgrade4"	};
			
			static const String itemstr[] =
			{	"$SSGUpgrade1",	"$SSGUpgrade2",	"$SSGUpgrade3",	"$SSGUpgrade4"	};
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					if (itemnames[i] == "SSGUpgrade4" &&
						(!CountInv("SSGUpgrade1") || !CountInv("SSGUpgrade2")))
						continue;
					
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class StaticRifleUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 10;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			// This one's entirely linear enough, so don't bother with randomizing.
			if (!CountInv("StaticUpgrade1"))
			{
				A_GiveInventory("StaticUpgrade1");
				A_PrintBold("$StaticUpgrade1");
			}
			else if (!CountInv("StaticUpgrade2"))
			{
				A_GiveInventory("StaticUpgrade2");
				A_PrintBold("$StaticUpgrade2");
			}
			else if (!CountInv("StaticUpgrade3"))
			{
				A_GiveInventory("StaticUpgrade3");
				A_PrintBold("$StaticUpgrade3");
			}
			else if (!CountInv("StaticUpgrade4"))
			{
				A_GiveInventory("StaticUpgrade4");
				A_PrintBold("$StaticUpgrade4");
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class RepeaterUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 11;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "RepeaterUpgradePiercing", "RepeaterUpgradeDamage", "RepeaterUpgradeAltDamage", "RepeaterUpgradeAltAmmo" };
			
			static const String itemstr[] =
			{ "$RepeaterUpgradePiercing", "$RepeaterUpgradeDamage", "$RepeaterUpgradeAltDamage", "$RepeaterUpgradeAltAmmo" };
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class AssaultRifleUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 4;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"AssaultRifleMod1",		"AssaultRifleMod2"	};
			
			static const String itemstr[] =
			{	"$AssaultRifleMod1",	"$AssaultRifleMod2"	};
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class ChaingunUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 5;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"ChaingunMod1",		"ChaingunMod2"	};
			
			static const String itemstr[] =
			{	"$ChaingunMod1",	"$ChaingunMod2"	};
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class RocketLauncherUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 6;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"RocketLauncherMod1",	"RocketLauncherMod2"	};
			
			static const String itemstr[] =
			{	"$RocketLauncherMod1",	"$RocketLauncherMod2"	};
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class PlasmaRifleUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 7;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"PlasmaRifleMod1",	"PlasmaRifleMod2"	};
			
			static const String itemstr[] =
			{	"$PlasmaRifleMod1",	"$PlasmaRifleMod2"	};
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class LightningGunUpgradePickup : D4UpgradePickup
{	
	Default
	{
		D4UpgradePickup.Frame 13;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "LGUpgradeAmmo", "LGUpgradeRange", "LGUpgradeDamage", "LGUpgradeAltFire" };
			
			static const String itemstr[] =
			{ "$LGUpgradeAmmo", "$LGUpgradeRange", "$LGUpgradeDamage", "$LGUpgradeAltFire" };
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class VortexRifleUpgradePickup : D4UpgradePickup
{	
	Default
	{
		D4UpgradePickup.Frame 12;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "VortexUpgradeDamage", "VortexUpgradeAmmo", "VortexUpgradeAltSpeed", "VortexUpgradeAltPierce" };
			
			static const String itemstr[] =
			{ "$VortexUpgradeDamage", "$VortexUpgradeAmmo", "$VortexUpgradeAltSpeed", "$VortexUpgradeAltPierce" };
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class GaussCannonUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 9;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{	"GaussCannonMod1",	"GaussCannonMod2"	};
			
			static const String itemstr[] =
			{	"$GaussCannonMod1",	"$GaussCannonMod2"	};
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class BFGUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 8;
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "BFGUpgrade1", "BFGUpgrade2", "BFGUpgrade3", "BFGUpgrade4" };
			
			static const String itemstr[] =
			{ "$BFGUpgrade1", "$BFGUpgrade2", "$BFGUpgrade3", "$BFGUpgrade4" };
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class CarrionCannonUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 14;
	}
	States
	{
	Spawn:
		M668 O 17;
		M669 O 17;
		Loop;
	Pickup:
		TNT1 A 0
		{
			static const Class<Inventory> itemnames[] =
			{ "CarrionUpgradePickup", "CarrionUpgradeAmmo", "CarrionUpgradeStun", "CarrionUpgradeTime" };
			
			static const String itemstr[] =
			{ "$CarrionUpgradePickup", "$CarrionUpgradeAmmo", "$CarrionUpgradeStun", "$CarrionUpgradeTime" };
			
			for (int i = 0; i < itemnames.Size(); i++)
			{
				if (itemnames[i] && !CountInv(itemnames[i]))
				{
					invoker.desc[invoker.index] = itemstr[i];
					invoker.items[invoker.index] = itemnames[i];
					invoker.index++;
				}
			}
			
			invoker.index--;
			int rng = random(0,invoker.index);
			
			if (invoker.items[rng])
			{
				A_PrintBold(invoker.desc[rng]);
				A_GiveInventory(invoker.items[rng]);
			}
			ACS_NamedExecute("SaveTokens",0,0,0,0);
			return true;
		}
		Stop;
	}
}

Class SovietChaingunUpgradePickup : D4UpgradePickup
{
	Default
	{
		D4UpgradePickup.Frame 25;
		+INVENTORY.ALWAYSPICKUP
		+BRIGHT
		Inventory.PickupSound "HOLYSHIT";
		Inventory.PickupMessage "For Mother Russia!";
		Translation "0:255=%[0.0,0.0,0.0]:[1.0,0.75,0.0]";
	}
	States
	{
	Pickup:
		TNT1 A 0
		{
			if (!CountInv("SovietToken"))
			{	
				A_SpawnItemEx("HolyShitScreamer",flags:SXF_NOCHECKPOSITION);
				A_SetInventory("SovietToken",1);
				A_SetInventory("SovietActive",1);
			}
			// BUGS THIS BIG BECOME FEATURES!
			A_SetInventory("D4Bullets",CountInv("D4Bullets") + 666,DefPtr,true);
		}
		Stop;
	}
}

Class HolyShitScreamer : Actor
{
	Default
	{
		+NOINTERACTION +NOBLOCKMAP +THRUACTORS +NOTONAUTOMAP
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 35 NoDelay A_PlaySound("HOLYSHIT",CHAN_VOICE,1,0,ATTN_NONE);
		Stop;
	}
}

/*
//Chainsaw
M668A = "M668A" {Spin=50}
M669A = "M669A" {Spin=50}
WPPKA = "WPPKA" {Spin=50}

//Pistol
M668B = "M668B" {Spin=50}
M669B = "M669B" {Spin=50}
WPPKB = "WPPKB" {Spin=50}

//Shotgun
M668C = "M668C" {Spin=50}
M669C = "M669C" {Spin=50}
WPPKC = "WPPKC" {Spin=50}

//Super Shotgun
M668D = "M668D" {Spin=50}
M669D = "M669D" {Spin=50}
WPPKD = "WPPKD" {Spin=50}

//Heavy Assault Rifle
M668E = "M668E" {Spin=50}
M669E = "M669E" {Spin=50}
WPPKE = "WPPKE" {Spin=50}

//Chaingun
M668F = "M668F" {Spin=50}
M669F = "M669F" {Spin=50}
WPPKF = "WPPKF" {Spin=50}

//Rocket Launcher
M668G = "M668G" {Spin=50}
M669G = "M669G" {Spin=50}
WPPKG = "WPPKG" {Spin=50}

//Plasma Rifle
M668H = "M668H" {Spin=50}
M669H = "M669H" {Spin=50}
WPPKH = "WPPKH" {Spin=50}

//BFG 9000
M668I = "M668I" {Spin=50}
M669I = "M669I" {Spin=50}
WPPKI = "WPPKI" {Spin=50}

//Gauss Cannon
M668J = "M668J" {Spin=50}
M669J = "M669J" {Spin=50}
WPPKJ = "WPPKJ" {Spin=50}

//Static rifle
M668K = "Voxels/staticNOTSELECTED.kvx" {scale=0.7 Spin=50}
M669K = "Voxels/staticSELECTED.kvx" {scale=0.7 Spin=50}
WPPKK = "WPPKK" {Spin=50}

//Repeater
M668L = "Voxels/repeaterNOTSELECTED.kvx" {scale=0.85 Spin=50}
M669L = "Voxels/repeaterSELECTED.kvx" {scale=0.85 Spin=50}
WPPKL = "Voxels/PickupRepeater.kvx" {Spin=50}

//Vortex Rifle
M668M = "Voxels/vortexNOTSELECTED.kvx" {scale=0.7 Spin=50}
M669M = "Voxels/vortexSELECTED.kvx" {scale=0.7 Spin=50}
WPPKM = "Voxels/PickupVortex.kvx" {Spin=50}

//Lightning Gun 
M668N = "Voxels/lgunNOTSELECTED.kvx" {scale=0.7 Spin=50}
M669N = "Voxels/lgunSELECTED.kvx" {scale=0.7 Spin=50}
WPPKN = "WPPKN" {Spin=50}

//Carrion Cannon
M668O = "Voxels/hellNOTSELECTED.kvx" {scale=0.7 Spin=50}
M669O = "Voxels/hellSELECTED.kvx" {scale=0.7 Spin=50}
WPPKO = "Voxels/PickupHellshot.kvx" {scale=0.7 Spin=50}
*/