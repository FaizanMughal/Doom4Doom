Struct ItemsToSave
{
	Array<String> ItemList;
	bool Init(bool chain = false, Actor plr = null)
	{
		static const String SavedItemsStr[] =
		{	
			"D4DCash",
			"AssaultRifleMod1", //1
			"AssaultRifleMod2",
			"ChaingunMod1",
			"ChaingunMod2",
			"GaussCannonMod1",
			"GaussCannonMod2",
			"PlasmaRifleMod1",
			"PlasmaRifleMod2",
			"RocketLauncherMod1",
			"RocketLauncherMod2",
			"ShotgunMod1",
			"ShotgunMod2",
			"SSGUpgrade1",
			"SSGUpgrade2",
			"SSGUpgrade3",
			"SSGUpgrade4",
			"PistolUpgradeAutomatic",
			"PistolUpgradeAltDamage",
			"PistolUpgradeAltCharge",
			"PistolUpgradeDamage",
			"PistolUpgradeLance",
			"BFGUpgrade1",
			"BFGUpgrade2",
			"BFGUpgrade3",
			"BFGUpgrade4", // 25
			"StaticUpgrade1",
			"StaticUpgrade2",
			"StaticUpgrade3",
			"StaticUpgrade4",
			"SovietActive",
			"SovietToken",
			"LGUpgradeAmmo",
			"LGUpgradeRange",
			"LGUpgradeDamage",
			"LGUpgradeAltFire",
			"VortexUpgradeDamage",
			"VortexUpgradeAmmo",
			"VortexUpgradeAltSpeed",
			"VortexUpgradeAltPierce",
			"RepeaterUpgradePiercing",
			"RepeaterUpgradeDamage",
			"RepeaterUpgradeAltDamage",
			"RepeaterUpgradeAltAmmo",
			"D4CarrionCannon",
			"D4CarrionToken",
			"CarrionLevel",
			"CarrionUpgradePickup",
			"CarrionUpgradeAmmo",
			"CarrionUpgradeStun",
			"CarrionUpgradeTime",
			"DollUses",
			"FragGrenadePickup",
			"HoloGrenadePickup",
			"SyphonGrenadePickup",
			"FragGrenadeSelected",
			"MarineHoloSelected",
			"SyphonGrenadeSelected",
			"D4Stamina",
			"ProtectionBonus",
			"ProtectionBonus1Real",
			"ProtectionBonus2",
			"ProtectionBonus3Real",
			"D4ArmorCapRaiser",
			"D4AirUpgrade",
			"D4AirControl",
			"D4HigherJump",
			"D4MultiJump",
			"D4CrateUpgrade",
			"CashPercentBonus",
			"D4MegasphereDamageReducer",
			"D4MegachargeUpgrade1",
			"D4MegachargeUpgrade2",
			"D4DoomDollUpgrade1",
			"D4DoomDollUpgrade2",
			"D4RegenUpgrade1",
			"D4RegenUpgrade2",
			"D4RegenUpgrade3",
			"D4RegenUpgrade4", // 77
			"D4PentagramUpgrade1",
			"D4PentagramUpgrade2",
			"D4PentagramUpgrade3",
			"D4PentagramUpgrade4",
			"D4RuneUpgrade1",
			"D4RuneUpgrade2",
			"D4RuneUpgrade3",
			"D4RuneUpgrade4" // 85
		};
		ItemList.Clear();
		
		if (chain)
		{
			if (!plr) return false;
			int amt;
			for (int i = 1; i < 26; i++)
			{
				Class<Inventory> check = SavedItemsStr[i];
				if (check && plr.CountInv(check))
					amt++;
			}
			return (amt >= 25);
		}
		
		for (int i = 0; i < SavedItemsStr.Size(); i++)
		{
			ItemList.Push (SavedItemsStr[i]);
		}
		return false;
	}
};

Class Doom4Player : PlayerPawn
{
	const DamageDegree = 8;
	const ZFlagCheck =	CLOFF_ALLOWNULL|CLOFF_SKIPTARGET|CLOFF_FROMBASE|
							CLOFF_JUMPENEMY|CLOFF_JUMPFRIEND|CLOFF_JUMPOBJECT|
							CLOFF_JUMPNONHOSTILE|CLOFF_JUMP_ON_MISS;
	const MaxRoll = 0.5;
	const CannonArmX = 83.0;
	const CannonArmY = 23.0;
	const CannonDestX = 83.0;
	const CannonDestY = 23.0;
	double UVel;
	double UZvel;
	double UHold;
	double Utime;
	double UVelx;
	double UVely;
	double Uaccx;
	double Uaccy;
	int Ulasthp;
	int Ucurrenthp;
	int UVel2; //Must be an int.
	int Uonce;
	int Uweapon;
	int UjumpsDone;
	int Ulowhp;
	int UordersJump;
	int UwasClimbing;
	int UclimbBouncePrevention;
	int GrenChargeCurrent;
	int DashTimer;
	double DashForward, DashSide, DashAngle;
	double UOffsets;
	bool spawned;
	Class<Actor> GrenadeToFire;
	Default 
	{
		+ALLOWPAIN
		+PLAYERPAWN.CROUCHABLEMORPH
		+NOICEDEATH
		+AIMREFLECT
		Speed 1;
		Health 100;
		Radius 16;
		Height 56;
		Mass 100;
		PainChance 255;
		Gravity 0.8;
		Player.DisplayName "Marine";
		Player.CrouchSprite "PLYC";
		Player.StartItem "D4Pistol";
		Player.StartItem "D4DFist";
	//	Player.StartItem "AkimboWeapon";
		Player.StartItem "TrishotClip", 3;
		Player.StartItem "D4MultiJump", 2;
		Player.JumpZ 7.0;
		Player.WeaponSlot 1, "D4DFist", "D4Chainsaw";
		Player.WeaponSlot 2, "D4Pistol";
		Player.WeaponSlot 3, "D4Shotgun", "D4SuperShotgun";	
		Player.WeaponSlot 4, "D4Repeater", "D4AssaultRifle", "D4Chaingun";
		Player.WeaponSlot 5, "D4GrenadeLauncher", "D4RocketLauncher";	
		Player.WeaponSlot 6, "D4LightningGun", "D4PlasmaRifle";
		Player.WeaponSlot 7, "D4StaticRifle", "D4VortexRifle", "D4GaussCannon";
		Player.WeaponSlot 8, "D4BFG", "D4CarrionCannon";
		Player.WeaponSlot 9, "AkimboWeapon";
		Player.ColorRange 112, 127;
		Player.ColorSet 0, "Green",         0x70, 0x7F,  0x72;
		Player.ColorSet 1, "Gray",          0x60, 0x6F,  0x62; // Called "Indigo" originally so as to have a unique initial
		Player.ColorSet 2, "Brown",         0x40, 0x4F,  0x42;
		Player.ColorSet 3, "Red",           0x20, 0x2F,  0x22;
		// Doom Legacy additions
		Player.ColorSet 4, "Light Gray",    0x58, 0x67,  0x5A;
		Player.ColorSet 5, "Light Brown",   0x38, 0x47,  0x3A;
		Player.ColorSet 6, "Light Red",     0xB0, 0xBF,  0xB2;
		Player.ColorSet 7, "Light Blue",    0xC0, 0xCF,  0xC2;
		
		Player.AttackZOffset 11; //13 is perfect, but makes projectiles hit below. so A middle point to fix the hitscan attacks not hitting where they should
		Player.ViewHeight 41;

		DamageFactor "HoloAttract", 0;
		PainChance "HoloAttract", 0;
		
		damagefactor "FriendBullet", 0.0;
		damagefactor "Taunt", 0.0;
		damagefactor "KillMe", 0.0;
		damagefactor "Shotgun", 0.7;
		damagefactor "Shrapnel", 0.0;
		damagefactor "Blood", 0.5;
		damagefactor "BlueBlood", 0.5;
		damagefactor "GreenBlood", 0.5;
		damagefactor "MinorHead", 0.0;
		damagefactor "Decaptate", 0.0;
		damagefactor "MonsterKnocked", 0.0;
		damagefactor "MonsterBullet", 0.33;
		damagefactor "MonsterShotgunBullet", 0.33;
		damagefactor "MonsterCutless", 0.33;
		damagefactor "CancelTeleportFog", 0.0;
		damagefactor "BHFTOnBarrel", 0.0;
		damagefactor "GibRemoving", 0.0;
		damagefactor "HelperMarineFatallity", 0.0;
		damagefactor "Leg", 0.0;
		damagefactor "SpawnMarine", 0.0;
		damagefactor "TeleportRemover", 0.0;
		DamageFactor "CauseObjectsToSplash", 0.0;
		damagefactor "Shotgun", 0.0;
		damagefactor "Cutless", 0.0;
		damagefactor "SSG", 0.0;
		damagefactor "Trample", 0.0;
		damagefactor "bullet", 0.0;
		damagefactor "cutless", 0.0;
		damagefactor "shotgun", 0.0;
		damagefactor "ssg", 0.0;
		PainChance "SpawnMarine", 0;
		PainChance "Leg", 0;
		PainChance "Taunt", 0;
		PainChance "FriendBullet", 0;
		PainChance "KillMe", 0;
		PainChance "Shrapnel", 0;
		PainChance "MinorHead", 0;
		PainChance "Decaptate", 0;
		PainChance "MonsterKnocked", 0;
		PainChance "CancelTeleportFog", 0;
		PainChance "BHFTOnBarrel", 0;
		PainChance "GibRemoving", 0;
		PainChance "HelperMarineFatallity", 0;
		PainChance "TeleportRemover", 0;
		PainChance "CauseObjectsToSplash", 0;
		PainChance "HoloAttract", 0;
		Species "Marines";
		+THRUSPECIES
		+MTHRUSPECIES
	}
	States
	{
	Spawn:
		PLAY A -1 NoDelay
		{
			if (player && player.mo && player.mo == self)
			{
				A_Overlay(Overlay_DashManager, "Overlay.DashManager", true);
				A_Overlay(Overlay_UtilityManager, "Overlay.UtilityManager", true);
				A_Overlay(Overlay_LedgeGrab,"Overlay.LedgeGrab",true);
			//	A_Overlay(99,"Overlay.Debug",true);
			}
		}
		Loop;
	//==========================================================================
	// Overlay:			Dash Manager
	// Deals with fast movement in a direction, horizontally.
	//==========================================================================
	Overlay.DashManager:
		M666 A 1
		{
			if (!player)	return ResolveState("Null");
			
			DashForward = DashSide = DashAngle = 0;
			if (!CountInv("D4Dash"))
			{
				A_OverlayFlags(OverlayID(), PSPF_ADDWEAPON|PSPF_ADDBOB|PSPF_POWDOUBLE|PSPF_CVARFAST, false);
				A_SetTics(17);
				return ResolveState(null);
			}
			if (DashTimer > 1) 
				DashTimer--; // Still waiting.
			else if (DashTimer == 1)
			{
				if (bONMOBJ || pos.z <= GetZAt() || A_CheckFloor("Null"))
					DashTimer = 0; // Can dash.
			}
			else if (DashTimer == -1)
			{
				int btns = GetPlayerInput(MODINPUT_BUTTONS);
				bool forward = (btns & BT_FORWARD);
				bool backward = (btns & BT_BACK);
				bool left = (btns & BT_MOVELEFT);
				bool right = (btns & BT_MOVERIGHT);
				if (forward || backward || left || right)
				{
					if (forward != backward && left != right)
					{
						if (forward)
						{
							DashAngle = 0;
							if (right != left)
								DashAngle += (left) ? 45 : -45;
							 
						}
						else
						{
							DashAngle = 180;
							if (right != left)
								DashAngle += (left) ? -45 : 45;
						}
					}
					else if (forward != backward || right != left)
					{
						if (forward != backward)
						{
							DashAngle = (backward) ? 180 : 0;
						}
						else if (right != left)
						{
							DashAngle = (left) ? 90 : -90;
						}
					}
					else
					{
						return ResolveState(null);
					}
					// Finally, check to make sure our desired angle isn't already
					// going the speed of stupid - NASCAR style. =B
					if (Vel.XY.Length() > 30.0)
					{
						double VelAng = VectorAngle(vel.x, vel.y);
						DashAngle = Normalize180(DashAngle);
						if (AbsAngle(VelAng,DashAngle + Angle) < 22.5)
							return ResolveState(null);
					}
					DashTimer = 6;
					DashAngle += Angle;
					return ResolveState("Overlay.Dashing");
				}
				else DashTimer = 0;
			}
			return ResolveState(null);
		}
		Wait;
	Overlay.Dashing:
		M666 AAAAAA 1
		{
			double vz = Max(0.0, vel.z);
			Vel3DFromAngle(30, DashAngle, 0);
			vel.z = vz;
		}
		M666 A 1
		{
			StateLabel next = "Overlay.DashManager";
			if (!bONMOBJ && z > GetZAt())
			{
				next = null;
				double vz = vel.z;
				Vel3DFromAngle(30, DashAngle, 0);
				vel.z = vz;
			}
			return ResolveState(next);
		}
		Wait;
	//==========================================================================
	// Overlay:			Utility Items
	// Deals with grenades, flame thrower, etc.
	//==========================================================================
	Overlay.UtilityManager:
		M201 A 1
		{
			let plr = player;
			if (!plr)	return ResolveState("Null");
			
			bool ThrowGrenade = (plr.cmd.buttons & BT_RELOAD) && !(plr.oldbuttons & BT_RELOAD);
			int MaxAmt = 0;
			let inv = GetDefaultByType("GrenadeCharge");
			MaxAmt = inv.MaxAmount;
			
			int OID = OverlayID();
			A_OverlayFlags(OID, PSPF_ADDWEAPON|PSPF_ADDBOB|PSPF_POWDOUBLE|PSPF_CVARFAST, false);
			A_OverlayOffset(OID, -CannonArmX, -CannonArmY, WOF_INTERPOLATE);
			
			if (GrenChargeCurrent >= MaxAmt)
			{
				if (ThrowGrenade)
				{
					static const Class<Inventory> GrenadeSelected[] =
					{
						"FragGrenadeSelected",
						"SyphonGrenadeSelected",
						"MarineHoloSelected"
					};
					
					static const Class<Actor> GrenadeTypes[] =
					{
						"D4FragGrenade",
						"D4SyphonGrenade",
						"D4PlayerHolograph"
					};
					
					int size = GrenadeSelected.Size();
					for (int i = 0; i < size; i++)
					{
						if (CountInv(GrenadeSelected[i]))
						{
							GrenadeToFire = GrenadeTypes[i];
							return ResolveState("DeployCannon");
						}
					}
					ACS_NamedExecute("GrenadeUnavailPrint",0,4); //print "No grenade available"
					A_PlaySound("Doom4/Player/Nope",CHAN_AUTO);
				}
			}
			else if (ThrowGrenade)
			{
				ACS_NamedExecute("GrenadeUnavailPrint",0,5); //print "grenade not ready"
				A_PlaySound("Doom4/Player/Nope",CHAN_AUTO);	
			}
			return ResolveState(null);
		}
		Loop;
	DeployCannon:
		M201 A 1 
		{
			int OID = OverlayID();
			double divisor = 2.0;
			double offx = (CannonArmX / divisor);
			double offy = (CannonArmY / divisor);
			if (OverlayX(OID) + offx >= 0)
			{
				return ResolveState("LaunchGrenade");
			}
			A_OverlayOffset(OID, offx, offy, WOF_ADD|WOF_INTERPOLATE);
			return ResolveState(null);
		}
		Wait;
	LaunchGrenade:
		M201 A 12
		{
			int OID = OverlayID();
			A_OverlayOffset(OID, 0, 0, WOF_INTERPOLATE);
			if (GrenadeToFire)
			{
				let inv = GetDefaultByType("GrenadeCharge");
				int Amt = inv.MaxAmount;
				A_TakeInventory("GrenadeCharge", Amt, 0);
			//	A_FireProjectile(GrenadeToFire, 0, false, -8, 6);
				Vector3 px, py, pz, origin;
				[px, py, pz] = Matrix4.GetAxes(Pitch,Angle,Roll);
				origin = Vec2OffsetZ(0,0,player.viewz) - 1.0 * px + -15.0 * py + 5.0 * pz;
				
				let gren = Spawn(GrenadeToFire, origin, ALLOW_REPLACE);
				if (gren)
				{
					gren.A_PlaySound("Doom4/Weapon/Grenade/ThrowGren",5);
					gren.target = self;
					gren.angle = angle;
					gren.Vel3DFromAngle(gren.speed, angle, pitch);
				}
			}
		}
	RetractCannon:
		M201 A 1 
		{
			int OID = OverlayID();
			double divisor = 2.0;
			double offx = (CannonArmX / divisor);
			double offy = (CannonArmY / divisor);
			if (OverlayX(OID) - offx <= CannonArmX)
			{
				return ResolveState(1);
			}
			A_OverlayOffset(OID, -offx, -offy, WOF_ADD|WOF_INTERPOLATE);
			return ResolveState(null);
		}
		Wait;
		M201 A 1 A_OverlayOffset(OverlayID(), -CannonArmX, -CannonArmY, WOF_INTERPOLATE);
		Goto Overlay.UtilityManager;
	
	//==========================================================================
	// Overlay: 		Gun Shifting (WIP)
	// Offsets the weapon whenever turning the camera angle/pitch.
	//==========================================================================
	// (Currently buggy with firing weapons. Needs more fine tuning.)
	Overlay.AnglePitch:
		M666 A 1
		{
			if (GetCvar("D4D_TurningBehavior"))
			{
				if (abs(UOffsets) < 10.0)
				{
					UOffsets += (GetPlayerInput(INPUT_YAW,DefPtr) / 32767.0) * 10.0;
					//A_LogFloat(UOffsets);
				}
				if (UOffsets != 0.0)
				{
					if (UOffsets < 1.0 && UOffsets > -1.0)
					{
						A_WeaponOffset(UOffsets,0,WOF_ADD);
						UOffsets = 0;
					}
					else if (UOffsets < 0.0)
					{
						A_WeaponOffset(UOffsets,0,WOF_ADD);
						UOffsets += 1.0;
					}
					else if (UOffsets > 0.0)
					{
						A_WeaponOffset(UOffsets,0,WOF_ADD);
						UOffsets -= 1.0;
					}
				}
			}
			else
			{	A_SetTics(35);	}
		}
		Loop;
	//==========================================================================
	// Overlay: 		Show surroundings
	// When given "ShowSurroundings" token, counts objects in two areas.
	//==========================================================================
	Overlay.Debug:
		M666 A 1
		{
			if(countInv("ShowSurroundings"))
			{
				A_SetInventory("DebugMonstersToken", countProximity("D4AbstractMonster", 2048, CPXF_ANCESTOR));
				A_SetInventory("DebugBiggiesToken",  countProximity("D4AbstractBiggie",  2048, CPXF_ANCESTOR));
				A_SetInventory("DebugBossesToken",   countProximity("D4AbstractBoss",    2048, CPXF_ANCESTOR));
				A_SetInventory("DebugMissilesToken", countProximity("D4AbstractMissile", 2048, CPXF_ANCESTOR));
			}
		}
		Loop;
	//==========================================================================
	// Overlay: 		Ledge Climbing
	// Monitors edge closeness and grabbing so the player can attempt mantling
	// up over them.
	//==========================================================================
	/*
		M666 A 0
		{
			if (GetCvar("D4D_AllowClimbing") == true)
			{
				UwasClimbing = CountInv("RlyClimb"); // to catch transitive states like 0->1 or 1->0
				A_SetInventory("RlyClimb",0);
				A_GiveInventory("Climbing",1);
				
				if (vel.x * vel.x + vel.y * vel.y > 4)
				{	A_SetInventory("Climbing",0);	}
				
				// Calculate a naive-derivative
				Uaccx = vel.x - UVelx;
				Uaccy = vel.y - UVely;
				
				if (Uaccx*Uaccx + Uaccy*Uaccy > 0.02)
				{	A_SetInventory("Climbing",0);	}
				
				// Update historical values
				UVelx = vel.x;
				UVely = vel.y;
				
				// Abort if way forward is free
				if (!A_CheckBlock("Null", CBF_DROPOFF, AAPTR_DEFAULT, 20,0,0))
				{
					// "Overlay.LedgeGrab.ForwardFail"
					//A_Log("fail: forward free");
					A_SetInventory("Climbing",0);
				}
				
				// Also suppress initial instability
				if (UclimbBouncePrevention > 0) 
				{
					//A_LogInt(UclimbBouncePrevention);
					A_GiveInventory("Climbing", UclimbBouncePrevention--);
				}
				
				if (!((GetPlayerInput(MODINPUT_BUTTONS)  == BT_FORWARD) &&	// Abort if doing anything except walking forward
					(GetPlayerInput(MODINPUT_OLDBUTTONS) == BT_FORWARD)))
				{	A_SetInventory("Climbing",0);	}
				
				if ((pitch >= 0) && (pos.z == floorz)) // Abort if not looking upward when grounded
				{	A_SetInventory("Climbing",0);	}
				
				return ResolveState(1);
			}
			bSlidesOnWalls = true;
			return ResolveState("Overlay.LedgeGrab");
		}
		M666 A 0 A_JumpIfInventory("Climbing", 1, "Overlay.LedgeGrab.TryClimb");
		M666 A 0 {bSlidesOnWalls = true;}
		Loop;
		*/
	Overlay.LedgeGrab:
		M666 A 1 ;
		M666 A 0
		{
			int waitTics = 14;
			if (!GetCvar("D4D_AllowClimbing"))
			{
				A_SetTics(waitTics);
			}
			else
			{
				//UwasClimbing
				//Uaccx
				//Uaccy
				//UVelx
				//UVely

				int DistCheck = 24;
				
				if (vel.x * vel.x + vel.y * vel.y > 4)
				{	return;		}
				
				// Abort if way forward is free
				if (!A_CheckBlock("Null", CBF_DROPOFF, AAPTR_DEFAULT, DistCheck,0,0))
				{	return;		}
				
				// Abort if doing anything except walking forward
				if (!((GetPlayerInput(MODINPUT_BUTTONS)  == BT_FORWARD) &&	
					(GetPlayerInput(MODINPUT_OLDBUTTONS) == BT_FORWARD)))
				{	return;		}
				
				// Abort if not looking upward when grounded
				if ((pitch >= 0) /*&& (pos.z == floorz)*/ ) 
				{	return;		}
				
				
				double newfloor = GetZAt(DistCheck,0,0);
				double newceiling = GetZAt(DistCheck,0,0,GZF_CEILING);
				double ledgedist = abs(newfloor - (pos.z + 36));
				// if player is below new floor by no more than ledgedist units
				// and can actually fit inside of it, mantle over.
				if ((ledgedist > 0) && (ledgedist <= 24) 
					&&
					(newfloor + height < ceilingz) &&
					(newceiling - newfloor >= height))
				{
					bSlidesOnWalls = false;
					for (int i = 0; i < 21; i += 2)
					{
						Vector3 np = Vec3Angle(DistCheck - i,angle,newfloor);
						if (!A_CheckBlock("Null",CBF_ABSOLUTEPOS,DefPtr,np.x,np.y,np.z,0))
						{
							A_Warp(DefPtr,np.x,np.y,np.z,0,WARPF_ABSOLUTEPOSITION|WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_STOP);
						//	A_Warp(DefPtr,flags: WARPF_TOFLOOR|WARPF_NOCHECKPOSITION);
							break;
						}
					}
						
					bSlidesOnWalls = true;
					A_SetTics(waitTics);
				}
			}
		}
		Loop;
	/*	
		
	Overlay.LedgeGrab.TryClimb:
		//M666 A 0; //A_Log("tryclimb")
		// Fail if way forward is free
		//M666 A 0; 
		// Succeed if way forward is free anywhere up to a player height and a bit more above
		Goto Overlay.LedgeGrab.TryClimb2;
		
	Overlay.LedgeGrab.TryClimb2:
		//M666 A 0; //A_Log("tryclimb2")
		M666 A 0 A_Warp(AAPTR_DEFAULT, 24,0,25 , 0, WARPF_TESTONLY, "Overlay.LedgeGrab.DoClimb2");
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.UpwardFail", CBF_DROPOFF, AAPTR_DEFAULT, 0,0,25);
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.TryClimb3", CBF_DROPOFF, AAPTR_DEFAULT, 20,0,25);
		Goto Overlay.LedgeGrab.DoClimb2;
	Overlay.LedgeGrab.TryClimb3:
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.UpwardFail", CBF_DROPOFF, AAPTR_DEFAULT, 0,0,height*3/6);
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.TryClimb4", CBF_DROPOFF, AAPTR_DEFAULT, 20,0,height*3/6);
		Goto Overlay.LedgeGrab.DoClimb3;
	Overlay.LedgeGrab.TryClimb4:
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.UpwardFail", CBF_DROPOFF, AAPTR_DEFAULT, 0,0,height*4/6);
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.TryClimb5", CBF_DROPOFF, AAPTR_DEFAULT, 20,0,height*4/6);
		Goto Overlay.LedgeGrab.DoClimb4;
	Overlay.LedgeGrab.TryClimb5:
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.UpwardFail", CBF_DROPOFF, AAPTR_DEFAULT, 0,0,height*5/6);
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.TryClimb6", CBF_DROPOFF, AAPTR_DEFAULT, 20,0,height*5/6);
		Goto Overlay.LedgeGrab.DoClimb5;
	Overlay.LedgeGrab.TryClimb6:
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.UpwardFail", CBF_DROPOFF, AAPTR_DEFAULT, 0,0,height*6/6);
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.TryClimb7", CBF_DROPOFF, AAPTR_DEFAULT, 20,0,height*6/6);
		Goto Overlay.LedgeGrab.DoClimb6;
	Overlay.LedgeGrab.TryClimb7:
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.UpwardFail", CBF_DROPOFF, AAPTR_DEFAULT, 0,0,height*7/6);
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.TryClimb8", CBF_DROPOFF, AAPTR_DEFAULT, 20,0,height*7/6);
		Goto Overlay.LedgeGrab.DoClimb7;
	Overlay.LedgeGrab.TryClimb8:
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab.UpwardFail", CBF_DROPOFF, AAPTR_DEFAULT, 0,0,height*8/6);
		M666 A 0 A_CheckBlock("Overlay.LedgeGrab", CBF_DROPOFF, AAPTR_DEFAULT, 20,0,height*8/6);
		Goto Overlay.LedgeGrab.DoClimb8;
		
	Overlay.LedgeGrab.UpwardFail:
		M666 A 0; //A_Log("fail: upward blocked")
		Goto Overlay.LedgeGrab;
		
	Overlay.LedgeGrab.DoClimb2:
		M666 A 0; //A_Log("doclimb2")
		Goto Overlay.LedgeGrab.DoClimb;
	Overlay.LedgeGrab.DoClimb3:
		M666 A 0; //A_Log("doclimb3")
		Goto Overlay.LedgeGrab.DoClimb;
	Overlay.LedgeGrab.DoClimb4:
		M666 A 0; //A_Log("doclimb4")
		Goto Overlay.LedgeGrab.DoClimb;
	Overlay.LedgeGrab.DoClimb5:
		M666 A 0; //A_Log("doclimb5")
		Goto Overlay.LedgeGrab.DoClimb;
	Overlay.LedgeGrab.DoClimb6:
		M666 A 0; //A_Log("doclimb6")
		Goto Overlay.LedgeGrab.DoClimb;
	Overlay.LedgeGrab.DoClimb7:
		M666 A 0; //A_Log("doclimb7")
		Goto Overlay.LedgeGrab.DoClimb;
	Overlay.LedgeGrab.DoClimb8:
		M666 A 0; //A_Log("doclimb8")
		Goto Overlay.LedgeGrab.DoClimb;
	Overlay.LedgeGrab.DoClimb:
		// transitive state detection
		M666 A 0
		{
			A_GiveInventory("RlyClimb",1);
			if(UwasClimbing == 0)
			{
				//A_Log("starting climbing");
				A_PlaySound("Doom4/Player/Climb",7);
				UclimbBouncePrevention = 5;
			}
		}
		M666 A 0
		{
			//A_Log("climbing");
			ACS_NamedExecuteAlways("SaveWeapon");
			A_GiveInventory("ClimbingHands",1);
			A_SelectWeapon("ClimbingHands");
			bSlidesOnWalls = false;
			
			if(vel.z < 0) 
			{	A_ChangeVelocity(vel.x/2,vel.y/2,vel.z/4,CVF_REPLACE); }
			if(vel.z < 5) 
			{	A_ChangeVelocity(0,0,1); }
			if(!A_CheckBlock("Overlay.LedgeGrab", CBF_DROPOFF, AAPTR_DEFAULT, 0,0,1))
			{	A_Warp(AAPTR_DEFAULT, 0,0,1, 0, WARPF_INTERPOLATE); }
			
		}
		Goto Overlay.LedgeGrab;
	*/

	See:
		PLAY ABCD 4 ;
		Loop;
		
	// These are separated for the sake of quad damage state findings.
	Missile:
		PLAY E 1;
	MissileCont:
		PLAY E 11;
		Goto Spawn;
	Melee:
		PLAY F 1 BRIGHT light("PlayerLight1");
	MeleeCont:
		PLAY F 1 bright light("PlayerLight2");
		PLAY F 1 bright light("PlayerLight3");
		PLAY F 1 bright light("PlayerLight4");
		PLAY F 1 bright light("PlayerLight5");
		PLAY F 1 bright light("PlayerLight6");
		Goto MissileCont;
	
	Pain:
		PLAY G 8 
		{
			if (CountInv("PowerInvulBase") || CountInv("PowerInvulnerable") || bInvulnerable || bNoDamage)
			{
				Ulowhp = 0;
				A_SetBlend("FFFFFF",0.15,5);
				//Just like Quake. Only happens once per two seconds.
			}
			else
			{
				Ucurrenthp = health + CountInv("BasicArmor");
				if (Ulasthp != Ucurrenthp)
				{
					A_SetBlend("99 00 00", .3, 5);
					Ulasthp = Ucurrenthp;
				}
				if ((GetCvar("D4D_BloodScreen")) && (Ulasthp - Ucurrenthp >= DamageDegree))
				{
					ACS_NamedExecuteAlways("Blood",0, int(floor((Ulasthp - Ucurrenthp) / DamageDegree)),0,0);
				}
				
				if (health <= 40)
				{
					if (Ulowhp == 0)
					{
						A_SpawnItemEx("LowHealthAlarm",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION);
						Ulowhp = 1;
					}
				}
				else
				{	Ulowhp = 0;	}
			}
		}
		Goto Spawn;
	Death:
		PLAY H 0 
		{
			if (A_PlayerSkinCheck("AltSkinDeath"))
			{	return ResolveState("AltSkinDeath");	}
			return ResolveState("Death1");
		}
	Death1:
		PLAY H 10;
		PLAY I 10 A_PlayerScream;
		PLAY J 10 A_NoBlocking();
		PLAY KLM 10;
		PLAY N -1;
		Stop;
	XDeath:
		PLAY O 0 
		{
			if (A_PlayerSkinCheck("AltSkinXDeath"))
			{	return ResolveState("AltSkinXDeath");	}
			return ResolveState("XDeath1");
		}
	XDeath1:
		TNT1 A 1 A_SpawnItemEx("BloodGibDropper",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_USEBLOODCOLOR);
		TNT1 A 1 A_XScream();
		TNT1 A 1 A_NoBlocking();
		TNT1 A -1;
		Stop;
	AltSkinDeath:
		TNT1 A 1 A_SpawnItemEx("BloodGibDropper",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_USEBLOODCOLOR);
		TNT1 A 1 A_PlayerScream;
		TNT1 A 1 A_NoBlocking();
		TNT1 A -1;
		Stop;
	AltSkinXDeath:
		TNT1 A 0 A_SpawnItemEx("BloodGibDropper",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_USEBLOODCOLOR);
		TNT1 A 1 A_PlayerScream;
		TNT1 A 0 A_NoBlocking();
		TNT1 A 1 A_SkullPop;
		TNT1 A -1;
		Stop;
	}
}

Class NewMapToken : Inventory
{	Default { Inventory.InterhubAmount 0; } }

Class LowHealthAlarm : Actor 
{
	Default 
	{
		+NOINTERACTION
		+NOTONAUTOMAP
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 20 NoDelay A_PlaySound("Doom4/Player/LowHealth",CHAN_AUTO,1,0,ATTN_NONE);
		Stop;
	}
}

Class Climbing : Inventory {}
Class RlyClimb : Inventory {}

extend class Doom4Player
{
	override void PostBeginPlay()
	{
		if (!player || !player.mo || player.mo != self)
		{
			return Super.PostBeginPlay();
		}
		
		Super.PostBeginPlay();
		
		if (self.GetClass() == "Doom4Player")
		{
			/*
			ItemsToSave ITS;
			ITS.Init();
			
			What is the point behind this? Simple. It gives
			and takes an inventory item so that it's technically 'present'
			yet at the same time acts as if it's not there, preventing it from
			being used.
			
			Why is it necessary? Because the upgrade menu cannot work without
			them. Each upgrade has a price attached to it (see Upgrades.txt)
			along with pre-requisites. This absolutely must be done or else
			the menu won't work.
			
			But this is only necessary for items that are not already present
			in the player's inventory. If they already are, it's obviously not
			in need of depleting. We just need to make sure they have the
			item available for the menu to read it, as it calls FindInventory
			which won't return null thanks to KEEPDEPLETED -- even if the 
			quantity is 0. Which is perfect.
			
			tl;dr the item's there for the menu while not being active until
			the player has 1+, nuff sed
			*/
			/*
			for (int i = 1; i < ITS.ItemList.Size(); i++)
			{
				Class<Inventory> check = ITS.ItemList[i];
				if (check && !CountInv(check))
				{
					A_SetInventory(check,1);
					A_SetInventory(check,0);	
				}
			}
			*/
			
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				bool doContinue = false;
				Class<D4DKeeperItem> Type = (Class<D4DKeeperItem>)(AllActorClasses[i]);
				if (Type != null)
				{
					// Make sure it's not the direct item itself.
					static const Class<Inventory> list[] =
					{
						"UpgradeItem",
						"D4DKeeperItem"
					};
					
					int Size = list.Size();
					for (int j = 0; j < Size; j++)
					{
						if (Type == list[j])
						{
							doContinue = true;
							break;
						}
					}					
					if (doContinue)	continue;
					
					if (!CountInv(Type))
					{
						A_SetInventory(Type,1);
						A_SetInventory(Type,0);
					}
				}
			}
			stamina = 0;
			A_SetHealth(100);
		}
	}
	
	//==========================================================================
	//
	//
	//
	//==========================================================================
	
	// [Gutawer]
	// I can never get the ** operator to actually work, so i'm using a function to do it
	double pow(double base, double power) { return exp(power * log(base)); }
	double effectSize;
	int PentaNoiseWait;
	
	//--------------------------------------------------------------------------
	// Damage Control
	//--------------------------------------------------------------------------
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (mod == 'HoloAttract')	return 0;
		
		let inv = BasicArmor(FindInventory("BasicArmor"));
		if (inv)
		{
			inv.MaxAbsorb = Max(inv.MaxAbsorb, 200);
			inv.MaxFullAbsorb = Max(inv.MaxFullAbsorb, 200);
			inv.SavePercent = 100.0;
		}
		
		if (source && source == self && CountInv("PowerD4QuadDamage"))
		{
			
			damage *= 0.25;
		}
		
		// Handle Pentagram of Protection effects here. Pretty much a copy/pasta
		// of the internal damage, including thrusting since it's needless to call
		// P_DamageMobj.
		if (bINVULNERABLE || bNODAMAGE || FindInventory("PowerInvulnerable",true) || CountInv("CantTouchThis"))
		{
			if (!(flags & DMG_NO_PROTECT))
				damage = GetModifiedDamage(mod, damage, true);
			if (!(flags & DMG_NO_FACTOR))
				damage = ApplyDamageFactor(mod, damage);
				
			if (damage < 1 && (!inflictor || (!inflictor.bCAUSEPAIN && !bALLOWPAIN)))
				return 0;
				
			if (CountInv("D4PentagramUpgrade3") && mod != 'Reflection' && damage > 0)
			{
				// Make sure never to do this to self! Otherwise, infiniloops happen.
				// Doze are bad. Weally weally bad. :(
				if (source && source != self && (source.bSHOOTABLE || source.bVULNERABLE))
				{
					source.DamageMobj(self, self, Max(1,damage * 0.2), "Reflection");
				}
				else if (inflictor && inflictor != self && (inflictor.bSHOOTABLE || inflictor.bVULNERABLE))
				{
					inflictor.DamageMobj(self, self, Max(1,damage * 0.2), "Reflection");
				}
			}
			
			double alfa = Clamp(0.01 + damage * 0.02, 0.01, 0.6);
			int fadetime = Clamp(damage * 0.1, 2, 70);
			A_SetBlend("White",alfa,fadetime);
			
			if (PentaNoiseWait < 1)
			{
				A_PlaySound("PentagramOfProtection/Protect",CHAN_VOICE);
				PentaNoiseWait = 70;
			}
			
			if (!bNODAMAGE)
			{
				Actor origin = (source && (flags & DMG_INFLICTOR_IS_PUFF))? source : inflictor;
				
				if (origin && !origin.bNODAMAGETHRUST && !bDONTTHRUST)
				{
					double ang = (flags & DMG_USEANGLE) ? angle : origin.AngleTo(self);
					double thrust = 32.0;
									
					if (mass > 0)
					{
						int kb = 1;
						
						if (inflictor)
						{
							kb = inflictor.projectileKickback;
						}
						else if (source)
						{
							kb = source.projectileKickback;
						}
						
						thrust = max((damage * 0.125 * kb) / mass, 0.0);
					}
					if (thrust >= 0.01)					
						Thrust(thrust, ang);	
				}
			}
			return 0;
		}
		
		// Can't touch dis.
		if (CountInv("CantTouchThis"))
		{
			bNODAMAGE = true;
			flags &= ~DMG_FORCED;
			damage = Clamp(damage, 0, TELEFRAG_DAMAGE - 1);
		}
		// Don't negate stuff if it's telefrag damage.
		else if (damage < TELEFRAG_DAMAGE)
		{
			// Reduce by 1% for every megasphere we've picked up.
			// DoomDoll does not give this bonus.
			let inv = FindInventory("D4MegasphereDamageReducer");
			if (inv)
			{
				int pc1 = Clamp(inv.Amount, 0, inv.MaxAmount);
				if (pc1 > 0)
				{
					double dmg = Max(0,damage * (1.0 - (0.01 * pc1)));
					damage = int(floor(dmg));
				}
			}
		}
		
		int ArmorBefore = 0;
		int ArmorAfter = 0;
		let arm = BasicArmor(FindInventory("BasicArmor"));
		if (arm)	ArmorBefore = arm.Amount;
		
		int finaldamage = Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		
		if (arm)	ArmorAfter = arm.Amount;
		if (finaldamage > 0)
		{
			effectSize += log(finaldamage) / 25.0;
		}
		else if (ArmorBefore > ArmorAfter)
		{
			effectSize += log(ArmorBefore - ArmorAfter) / 25.0;
		}
		return finaldamage;
	}
	
	override bool CanCollideWith (Actor other, bool passive)
	{
		if (!passive)
		{
			// Upgrade 2 allows passing through enemies with invulnerability.
			if (FindInventory("PowerInvulnerable",true) && 
				CountInv("D4PentagramUpgrade2") && 
				other.bISMONSTER)
			{
				return false;
			}
		}
		else
		{
			if (other.FindInventory("PowerInvulnerable", true) &&
				other.CountInv("D4PentagramUpgrade2"))
				return false;
		}
		return true;
	}
	
	//--------------------------------------------------------------------------
	//
	// Start-up
	//
	//--------------------------------------------------------------------------
	
	bool started;
	
	void InitPlayer()
	{
		if (!started) 
		{
			if (GetCvar("skill") >= 3)
			{
				if (GetCvar("D4D_NMGrenades") >= 1) // Give and select frag if the setting isn't "Off" 
				{
					if (!CountInv("FragGrenadePickup"))
					{	
						A_SetInventory("GrenadeCharge", 350);
						A_SetInventory("FragGrenadePickup",1);
						A_SetInventory("FragGrenadeSelected",1);
					}
				}
				if (GetCvar("D4D_NMGrenades") >= 2) // Give the rest and select syphon if the setting is "All"
				{
					if (!CountInv("HoloGrenadePickup"))
					{
						A_SetInventory("GrenadeCharge", 350);
						A_GiveInventory("HoloGrenadePickup",1);
					}
					if (!CountInv("SyphonGrenadePickup"))
					{   
						A_SetInventory("GrenadeCharge", 350);
						A_GiveInventory("GrenadeSelectedStripper",1); //Just in case
						A_SetInventory("SyphonGrenadePickup",1);
						A_SetInventory("SyphonGrenadeSelected",1); 
					}
				}
			}
		}
		started = true;
		
		//A_SetInventory("D4MultiJump",int(GetCvar("D4MultiJump")));
		UOffsets =
		UVel = UZvel = UHold = Utime = UVel2 = 
		Uonce =	UjumpsDone = Ulowhp = 0;
	}
	
	//--------------------------------------------------------------------------
	//
	//--------------------------------------------------------------------------
	
	//--------------------------------------------------------------------------
	//
	// Active Functions
	//
	//--------------------------------------------------------------------------
	
	override void Tick()
	{
		Super.Tick();
		if ((!player || !player.mo || player.mo != self) || health <= 0)	
			return;
		
		//======================================================================
			
		let inv = FindInventory("GrenadeCharge");
		if (!inv || inv.Amount < inv.MaxAmount)
		{
			A_GiveInventory("GrenadeCharge",1);
			if (!inv)	inv = FindInventory("GrenadeCharge");
			if (inv && inv.Amount >= inv.MaxAmount)
				A_PlaySound("Doom4/Weapon/Grenade/GrenadeRegen");
		}
		GrenChargeCurrent = (inv) ? inv.Amount : 0;
		//======================================================================
		if (effectSize > 0) {
			Shader.SetEnabled(player, "damageshader", true);
			Shader.SetUniform1f(player, "damageshader", "damageFactor", effectSize);
		}
		else Shader.SetEnabled(player, "damageshader", false);
		
		double returnSpeed = 0;
		if (effectSize != 0) returnSpeed = pow(0.01, 1/(effectSize * 5));
		if (returnSpeed < 0.01) returnSpeed = 0.01;
		
		effectSize -= returnSpeed;
		effectSize = clamp(effectSize, 0, 0.5);
		//======================================================================
		
		let plyr = self.player;
		
		if (plyr && plyr.onground)
		{
			UjumpsDone = 0;
		}
		if (PentaNoiseWait > 0)	PentaNoiseWait--;
		if (level.maptime <= 1)	
		{
			let Tracker = D4DDeathStorage.Get();
		
			if (Tracker)
			{
				if (Tracker.died)
				{
					for (int i = 0; i < Tracker.ItemList.Size(); i++)
					{
						Class<Inventory> checker = Tracker.ItemList[i];
						if (checker != null)
							A_SetInventory(checker, Tracker.ItemCount[i]);
						else
							A_Log(Tracker.ItemList[i].." is invalid");
					}
				}
				Tracker.Destroy();
			}
			
			InitPlayer();
		}
		
		//======================================================================
		//	Cooldowns
		//======================================================================
		
		int timer = level.maptime % 30;
		// No need to check for StaticChargeDrain since the upgrade alone
		// shuts this off.
		if (!(timer % 3))
		{
			if (!CountInv("StaticUpgrade4"))
			{
					 if (CountInv("StaticUpgrade3"))
					A_TakeInventory("StaticRifleChargingToken",1);	
				else if (CountInv("StaticUpgrade2"))
					A_TakeInventory("StaticRifleChargingToken",2);	
				else
					A_TakeInventory("StaticRifleChargingToken",3);	
			}
			A_TakeInventory("PlasmaStunBombCounter",1);
			Ulasthp = health + CountInv("BasicArmor");
		}
		
		if (!(timer % 2))
		{
			A_TakeInventory("SGTripleShotTimer",1);
			A_TakeInventory("SGGrenadeTimer",1);
		}
		/*
		if (!(timer % 10))
		{
			if (CountInv("GrenadeCooldown"))
			{
				A_TakeInventory("GrenadeCooldown",1);
				if (!CountInv("GrenadeCooldown"))
				{
					A_PlaySound("Doom4/Weapon/Grenade/GrenadeRegen");
				}
			}
		}
		*/
		//----------------------------------------------------------------------
		
		if (GetClass() == "Doom4Player")
		{
			let p = self.player;
			let wep = p.ReadyWeapon;
			if (wep && wep.GetClass() == "D4StaticRifle")
			{
				if (CountInv("StaticChargeDrain"))
				{
					if (CountInv("StaticRifleChargingToken") > 540)
					{
						A_SetInventory("StaticRifleChargingToken",540);
					}
					else if (CountInv("StaticRifleChargingToken"))
					{
						A_TakeInventory("StaticRifleChargingToken",32);
						if (!CountInv("StaticRifleChargingToken"))
						{	A_SetInventory("StaticChargeDrain",0);	}
					}
					else
					{	A_SetInventory("StaticChargeDrain",0);	}
				}
				else if (CountInv("StaticRifleChargingToken") < 540)
				{
					UVel = vel.Length();
					if (CountInv("StaticRifleActive") && (UVel * 0.25) >= 1.0)
					{
							 if (CountInv("StaticUpgrade4"))		A_GiveInventory("StaticRifleChargingToken", int((UVel * 2.9) * 0.25));	
						else if (CountInv("StaticUpgrade3"))		A_GiveInventory("StaticRifleChargingToken", int((UVel * 2.55) * 0.25));	
						else if (CountInv("StaticUpgrade2"))		A_GiveInventory("StaticRifleChargingToken", int((UVel * 2.2) * 0.25));	
						else if (CountInv("StaticUpgrade1"))		A_GiveInventory("StaticRifleChargingToken", int((UVel * 1.85) * 0.25));	
						else										A_GiveInventory("StaticRifleChargingToken", int((UVel * 1.5) * 0.25));	
					}
				}
			}
			
			if (CountInv("D4IdfaTrap")) { A_GiveInventory("IdfaStamp"); A_SetInventory("D4IdfaTrap",0); }
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC P_CheckJump
	//
	//----------------------------------------------------------------------------
	//bool justJumped;
	override void CheckJump()
	{
		
		let player = self.player;
		// [RH] check for jump
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
				UjumpsDone = 1;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
				UjumpsDone = 1;
			}
			else if (level.IsJumpingAllowed())
			{
				if (player.onground)
				{				
					// Regular jump
					if (player.jumpTics == 0)
					{
						UjumpsDone = 1;
						double jumpvelz = JumpZ * 35 / TICRATE;
						double jumpfac = 0;

						// [BC] If the player has the high jump power, double his jump velocity.
						// (actually, pick the best factors from all active items.)
						for (let p = Inv; p != null; p = p.Inv)
						{
							let pp = PowerHighJump(p);
							if (pp)
							{
								double f = pp.Strength;
								if (f > jumpfac) jumpfac = f;
							}
						}
						if (jumpfac > 0) jumpvelz *= jumpfac;

						Vel.Z += jumpvelz + CountInv("D4HigherJump");
						bOnMobj = false;
						player.jumpTics = -1;
						if (!(player.cheats & CF_PREDICTING)) 
						{
							A_PlaySound("*jump", CHAN_BODY);
						}
					}
				}
				else if (GetClass() == 'Doom4Player' && 
					GetCvar("D4D_MultiJump") && 
					(UjumpsDone < CountInv("D4MultiJump") - 1) && 
					!(GetPlayerInput(MODINPUT_OLDBUTTONS) & BT_JUMP))
				{
					if (Vel.Z < 0.0)	Vel.Z = 0.0;
						
					Vel.Z += (8.2 + CountInv("D4HigherJump"));
					UjumpsDone++;
					A_PlaySound("Doom4/Player/DoubleJump");
				}
			}
		}
	}
	
	override void MovePlayer()
	{
		Super.MovePlayer();
		if (GetClass() == 'Doom4Player')
		{
			let plyr = self.player;
			if (plyr)
			{
				if (CountInv("D4AirControl") && !plyr.onground)
				{
					int gpi = GetPlayerInput(MODINPUT_BUTTONS);
					
					if (gpi & (BT_FORWARD|BT_BACK|BT_MOVELEFT|BT_MOVERIGHT))
					{
						A_ChangeVelocity(
						((gpi & BT_FORWARD  ) ? .8 : 0) - 
						((gpi & BT_BACK     ) ? .8 : 0),
						((gpi & BT_MOVELEFT ) ? .8 : 0) -
						((gpi & BT_MOVERIGHT) ? .8 : 0),
						0,CVF_RELATIVE);
						
						vel *= 0.95;
					}
				}
			}
		}
	}
	
	override void CheatTake (String name, int amount)
	{
		bool takeall;
		Class<Inventory> type;
		let player = self.player;


		if (player.mo == NULL || player.health <= 0)
		{
			return;
		}
		
		if (takeall || name ~== "armor")
		{
			A_GiveInventory("ArmorStripper",1);
			//CheatTakeType("Armor");
			if (!takeall)
				return;
		}
		
		return Super.CheatTake(name, amount);
	}
	
	//--------------------------------------------------------------------------
	//
	//--------------------------------------------------------------------------
	override void Die(Actor source, Actor inflictor, int dmgflags)
	{
		if (!player || !player.mo || player.mo != self)
			return Super.Die(source, inflictor, dmgflags);
			
		
		
		ItemsToSave ITS;
		
		if (ITS.ItemList.Size() < 1)
			ITS.Init();
		
		let Tracker = D4DDeathStorage.Get();
		if (Tracker)
		{
			Tracker.died = true;
			Tracker.ItemList.Clear();
			Tracker.ItemCount.Clear();
			for (int i = 0; i < ITS.ItemList.Size(); i++)
			{
				// Make sure the item is a real one. Otherwise, notify the players
				// to report this to developers.
				Class<Inventory> checker = ITS.ItemList[i];
				if (checker == null)
				{
					A_Log(ITS.ItemList[i].." is not an item! Report to devs!");
					continue;
				}
				
				
				// Either save or restore it.
				int amt = CountInv(checker);
				//mCheck.SetInt(amt);
				
				Tracker.ItemList.Push(ITS.ItemList[i]);
				Tracker.ItemCount.Push(amt);
				CVar debug = CVar.FindCVar("D4Debug");
				if (debug && debug.GetInt() > 0)
				{
					String msg = String.Format("%s : %d ", ITS.ItemList[i], amt);
					A_Log(msg);
				}
			}
		}
		
		Super.Die(source, inflictor, dmgflags);
		
		A_RadiusGive("SyphonDestroyer",16386,RGF_MISSILES,1,"D4SyphonGrenade");
		for (int i = 1; i < 9; i++)
			A_StopSound(i);
		A_Overlay(1,"Null");
		A_ClearOverlays();
	}
	
	void TryDash()
	{
		if (!DashTimer && health > 0)	DashTimer = -1;
	}
}

/*==============================================================================



==============================================================================*/

class D4DDeathStorage : Thinker
{
	bool died;
	Array<String> ItemList;
	Array<Int> ItemCount;
	//--------------------------------------------------------------------------
	// Functions
	//--------------------------------------------------------------------------
	
	D4DDeathStorage Init()
	{
		ChangeStatNum(STAT_STATIC);
		return self;
	}

	static D4DDeathStorage Get()
	{
		ThinkerIterator it = ThinkerIterator.Create("D4DDeathStorage",STAT_STATIC);
		let p = D4DDeathStorage(it.Next());
		if (p == null)
		{
			p = new("D4DDeathStorage").Init();
		}
		return p;
	}
}
